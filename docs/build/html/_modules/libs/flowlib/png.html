

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>libs.flowlib.png &mdash; DF-VO 1.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> DF-VO
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../rsts/introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rsts/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rsts/examples.html">Examples</a></li>
</ul>
<p class="caption"><span class="caption-text">Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../DF-VO/apis.html">apis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../DF-VO/libs.html">libs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../DF-VO/tools.html">tools</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">DF-VO</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>libs.flowlib.png</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for libs.flowlib.png</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>

<span class="c1"># png.py - PNG encoder/decoder in pure Python</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2006 Johann C. Rocholl &lt;johann@browsershots.org&gt;</span>
<span class="c1"># Portions Copyright (C) 2009 David Jones &lt;drj@pobox.com&gt;</span>
<span class="c1"># And probably portions Copyright (C) 2006 Nicko van Someren &lt;nicko@nicko.org&gt;</span>
<span class="c1">#</span>
<span class="c1"># Original concept by Johann C. Rocholl.</span>
<span class="c1">#</span>
<span class="c1"># LICENCE (MIT)</span>
<span class="c1">#</span>
<span class="c1"># Permission is hereby granted, free of charge, to any person</span>
<span class="c1"># obtaining a copy of this software and associated documentation files</span>
<span class="c1"># (the &quot;Software&quot;), to deal in the Software without restriction,</span>
<span class="c1"># including without limitation the rights to use, copy, modify, merge,</span>
<span class="c1"># publish, distribute, sublicense, and/or sell copies of the Software,</span>
<span class="c1"># and to permit persons to whom the Software is furnished to do so,</span>
<span class="c1"># subject to the following conditions:</span>
<span class="c1">#</span>
<span class="c1"># The above copyright notice and this permission notice shall be</span>
<span class="c1"># included in all copies or substantial portions of the Software.</span>
<span class="c1">#</span>
<span class="c1"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="c1"># EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="c1"># MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="c1"># NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS</span>
<span class="c1"># BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN</span>
<span class="c1"># ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span>
<span class="c1"># CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="c1"># SOFTWARE.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Pure Python PNG Reader/Writer</span>

<span class="sd">This Python module implements support for PNG images (see PNG</span>
<span class="sd">specification at http://www.w3.org/TR/2003/REC-PNG-20031110/ ). It reads</span>
<span class="sd">and writes PNG files with all allowable bit depths</span>
<span class="sd">(1/2/4/8/16/24/32/48/64 bits per pixel) and colour combinations:</span>
<span class="sd">greyscale (1/2/4/8/16 bit); RGB, RGBA, LA (greyscale with alpha) with</span>
<span class="sd">8/16 bits per channel; colour mapped images (1/2/4/8 bit).</span>
<span class="sd">Adam7 interlacing is supported for reading and</span>
<span class="sd">writing.  A number of optional chunks can be specified (when writing)</span>
<span class="sd">and understood (when reading): ``tRNS``, ``bKGD``, ``gAMA``.</span>

<span class="sd">For help, type ``import png; help(png)`` in your python interpreter.</span>

<span class="sd">A good place to start is the :class:`Reader` and :class:`Writer`</span>
<span class="sd">classes.</span>

<span class="sd">Requires Python 2.3.  Limited support is available for Python 2.2, but</span>
<span class="sd">not everything works.  Best with Python 2.4 and higher.  Installation is</span>
<span class="sd">trivial, but see the ``README.txt`` file (with the source distribution)</span>
<span class="sd">for details.</span>

<span class="sd">This file can also be used as a command-line utility to convert</span>
<span class="sd">`Netpbm &lt;http://netpbm.sourceforge.net/&gt;`_ PNM files to PNG, and the</span>
<span class="sd">reverse conversion from PNG to PNM. The interface is similar to that</span>
<span class="sd">of the ``pnmtopng`` program from Netpbm.  Type ``python png.py --help``</span>
<span class="sd">at the shell prompt for usage and a list of options.</span>

<span class="sd">A note on spelling and terminology</span>
<span class="sd">----------------------------------</span>

<span class="sd">Generally British English spelling is used in the documentation.  So</span>
<span class="sd">that&#39;s &quot;greyscale&quot; and &quot;colour&quot;.  This not only matches the author&#39;s</span>
<span class="sd">native language, it&#39;s also used by the PNG specification.</span>

<span class="sd">The major colour models supported by PNG (and hence by PyPNG) are:</span>
<span class="sd">greyscale, RGB, greyscale--alpha, RGB--alpha.  These are sometimes</span>
<span class="sd">referred to using the abbreviations: L, RGB, LA, RGBA.  In this case</span>
<span class="sd">each letter abbreviates a single channel: *L* is for Luminance or Luma</span>
<span class="sd">or Lightness which is the channel used in greyscale images; *R*, *G*,</span>
<span class="sd">*B* stand for Red, Green, Blue, the components of a colour image; *A*</span>
<span class="sd">stands for Alpha, the opacity channel (used for transparency effects,</span>
<span class="sd">but higher values are more opaque, so it makes sense to call it</span>
<span class="sd">opacity).</span>

<span class="sd">A note on formats</span>
<span class="sd">-----------------</span>

<span class="sd">When getting pixel data out of this module (reading) and presenting</span>
<span class="sd">data to this module (writing) there are a number of ways the data could</span>
<span class="sd">be represented as a Python value.  Generally this module uses one of</span>
<span class="sd">three formats called &quot;flat row flat pixel&quot;, &quot;boxed row flat pixel&quot;, and</span>
<span class="sd">&quot;boxed row boxed pixel&quot;.  Basically the concern is whether each pixel</span>
<span class="sd">and each row comes in its own little tuple (box), or not.</span>

<span class="sd">Consider an image that is 3 pixels wide by 2 pixels high, and each pixel</span>
<span class="sd">has RGB components:</span>

<span class="sd">Boxed row flat pixel::</span>

<span class="sd">  list([R,G,B, R,G,B, R,G,B],</span>
<span class="sd">       [R,G,B, R,G,B, R,G,B])</span>

<span class="sd">Each row appears as its own list, but the pixels are flattened so</span>
<span class="sd">that three values for one pixel simply follow the three values for</span>
<span class="sd">the previous pixel.  This is the most common format used, because it</span>
<span class="sd">provides a good compromise between space and convenience.  PyPNG regards</span>
<span class="sd">itself as at liberty to replace any sequence type with any sufficiently</span>
<span class="sd">compatible other sequence type; in practice each row is an array (from</span>
<span class="sd">the array module), and the outer list is sometimes an iterator rather</span>
<span class="sd">than an explicit list (so that streaming is possible).</span>

<span class="sd">Flat row flat pixel::</span>

<span class="sd">  [R,G,B, R,G,B, R,G,B,</span>
<span class="sd">   R,G,B, R,G,B, R,G,B]</span>

<span class="sd">The entire image is one single giant sequence of colour values.</span>
<span class="sd">Generally an array will be used (to save space), not a list.</span>

<span class="sd">Boxed row boxed pixel::</span>

<span class="sd">  list([ (R,G,B), (R,G,B), (R,G,B) ],</span>
<span class="sd">       [ (R,G,B), (R,G,B), (R,G,B) ])</span>

<span class="sd">Each row appears in its own list, but each pixel also appears in its own</span>
<span class="sd">tuple.  A serious memory burn in Python.</span>

<span class="sd">In all cases the top row comes first, and for each row the pixels are</span>
<span class="sd">ordered from left-to-right.  Within a pixel the values appear in the</span>
<span class="sd">order, R-G-B-A (or L-A for greyscale--alpha).</span>

<span class="sd">There is a fourth format, mentioned because it is used internally,</span>
<span class="sd">is close to what lies inside a PNG file itself, and has some support</span>
<span class="sd">from the public API.  This format is called packed.  When packed,</span>
<span class="sd">each row is a sequence of bytes (integers from 0 to 255), just as</span>
<span class="sd">it is before PNG scanline filtering is applied.  When the bit depth</span>
<span class="sd">is 8 this is essentially the same as boxed row flat pixel; when the</span>
<span class="sd">bit depth is less than 8, several pixels are packed into each byte;</span>
<span class="sd">when the bit depth is 16 (the only value more than 8 that is supported</span>
<span class="sd">by the PNG image format) each pixel value is decomposed into 2 bytes</span>
<span class="sd">(and `packed` is a misnomer).  This format is used by the</span>
<span class="sd">:meth:`Writer.write_packed` method.  It isn&#39;t usually a convenient</span>
<span class="sd">format, but may be just right if the source data for the PNG image</span>
<span class="sd">comes from something that uses a similar format (for example, 1-bit</span>
<span class="sd">BMPs, or another PNG file).</span>

<span class="sd">And now, my famous members</span>
<span class="sd">--------------------------</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.0.18&quot;</span>

<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="c1"># http://www.python.org/doc/2.4.4/lib/module-operator.html</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">struct</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="c1"># http://www.python.org/doc/2.4.4/lib/module-warnings.html</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">zlib</span>

<span class="kn">from</span> <span class="nn">array</span> <span class="k">import</span> <span class="n">array</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">reduce</span>

<span class="k">try</span><span class="p">:</span>
    <span class="c1"># `cpngfilters` is a Cython module: it must be compiled by</span>
    <span class="c1"># Cython for this import to work.</span>
    <span class="c1"># If this import does work, then it overrides pure-python</span>
    <span class="c1"># filtering functions defined later in this file (see `class</span>
    <span class="c1"># pngfilters`).</span>
    <span class="kn">import</span> <span class="nn">cpngfilters</span> <span class="k">as</span> <span class="nn">pngfilters</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Image&#39;</span><span class="p">,</span> <span class="s1">&#39;Reader&#39;</span><span class="p">,</span> <span class="s1">&#39;Writer&#39;</span><span class="p">,</span> <span class="s1">&#39;write_chunks&#39;</span><span class="p">,</span> <span class="s1">&#39;from_array&#39;</span><span class="p">]</span>

<span class="c1"># The PNG signature.</span>
<span class="c1"># http://www.w3.org/TR/PNG/#5PNG-file-signature</span>
<span class="n">_signature</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;8B&#39;</span><span class="p">,</span> <span class="mi">137</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">78</span><span class="p">,</span> <span class="mi">71</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

<span class="n">_adam7</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
          <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">group</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="c1"># See http://www.python.org/doc/2.6/library/functions.html#zip</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span> <span class="o">*</span> <span class="n">n</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">isarray</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">array</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">tostring</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">row</span><span class="o">.</span><span class="n">tostring</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">interleave_planes</span><span class="p">(</span><span class="n">ipixels</span><span class="p">,</span> <span class="n">apixels</span><span class="p">,</span> <span class="n">ipsize</span><span class="p">,</span> <span class="n">apsize</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interleave (colour) planes, e.g. RGB + A = RGBA.</span>

<span class="sd">    Return an array of pixels consisting of the `ipsize` elements of</span>
<span class="sd">    data from each pixel in `ipixels` followed by the `apsize` elements</span>
<span class="sd">    of data from each pixel in `apixels`.  Conventionally `ipixels`</span>
<span class="sd">    and `apixels` are byte arrays so the sizes are bytes, but it</span>
<span class="sd">    actually works with any arrays of the same type.  The returned</span>
<span class="sd">    array is the same type as the input arrays which should be the</span>
<span class="sd">    same type as each other.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">itotal</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ipixels</span><span class="p">)</span>
    <span class="n">atotal</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">apixels</span><span class="p">)</span>
    <span class="n">newtotal</span> <span class="o">=</span> <span class="n">itotal</span> <span class="o">+</span> <span class="n">atotal</span>
    <span class="n">newpsize</span> <span class="o">=</span> <span class="n">ipsize</span> <span class="o">+</span> <span class="n">apsize</span>
    <span class="c1"># Set up the output buffer</span>
    <span class="c1"># See http://www.python.org/doc/2.4.4/lib/module-array.html#l2h-1356</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">ipixels</span><span class="o">.</span><span class="n">typecode</span><span class="p">)</span>
    <span class="c1"># It&#39;s annoying that there is no cheap way to set the array size :-(</span>
    <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ipixels</span><span class="p">)</span>
    <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">apixels</span><span class="p">)</span>
    <span class="c1"># Interleave in the pixel data</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ipsize</span><span class="p">):</span>
        <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">newtotal</span><span class="p">:</span><span class="n">newpsize</span><span class="p">]</span> <span class="o">=</span> <span class="n">ipixels</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">itotal</span><span class="p">:</span><span class="n">ipsize</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">apsize</span><span class="p">):</span>
        <span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">ipsize</span><span class="p">:</span><span class="n">newtotal</span><span class="p">:</span><span class="n">newpsize</span><span class="p">]</span> <span class="o">=</span> <span class="n">apixels</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">atotal</span><span class="p">:</span><span class="n">apsize</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">check_palette</span><span class="p">(</span><span class="n">palette</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check a palette argument (to the :class:`Writer` class)</span>
<span class="sd">    for validity.  Returns the palette as a list if okay; raises an</span>
<span class="sd">    exception otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># None is the default and is allowed.</span>
    <span class="k">if</span> <span class="n">palette</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">p</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">palette</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">256</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;a palette must have between 1 and 256 entries&quot;</span><span class="p">)</span>
    <span class="n">seen_triple</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;palette entry </span><span class="si">%d</span><span class="s2">: entries must be 3- or 4-tuples.&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">seen_triple</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">seen_triple</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;palette entry </span><span class="si">%d</span><span class="s2">: all 4-tuples must precede all 3-tuples&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="n">x</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">255</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;palette entry </span><span class="si">%d</span><span class="s2">: values must be integer: 0 &lt;= x &lt;= 255&quot;</span> <span class="o">%</span>
                    <span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p</span>


<span class="k">def</span> <span class="nf">check_sizes</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check that these arguments, in supplied, are consistent.</span>
<span class="sd">    Return a (width, height) pair.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">size</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;size argument should be a pair (width, height)&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">width</span> <span class="o">!=</span> <span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;size[0] (</span><span class="si">%r</span><span class="s2">) and width (</span><span class="si">%r</span><span class="s2">) should match when both are used.&quot;</span> <span class="o">%</span>
            <span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">width</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">height</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">height</span> <span class="o">!=</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;size[1] (</span><span class="si">%r</span><span class="s2">) and height (</span><span class="si">%r</span><span class="s2">) should match when both are used.&quot;</span> <span class="o">%</span>
            <span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">height</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">size</span>


<span class="k">def</span> <span class="nf">check_color</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">greyscale</span><span class="p">,</span> <span class="n">which</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks that a colour argument for transparent or</span>
<span class="sd">    background options is the right form.  Returns the colour</span>
<span class="sd">    (which, if it&#39;s a bar integer, is &quot;corrected&quot; to a 1-tuple).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">c</span>
    <span class="k">if</span> <span class="n">greyscale</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> for greyscale must be 1-tuple&quot;</span> <span class="o">%</span> <span class="n">which</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isinteger</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> colour for greyscale must be integer&quot;</span> <span class="o">%</span> <span class="n">which</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">isinteger</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">isinteger</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="ow">and</span> <span class="n">isinteger</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">])):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> colour must be a triple of integers&quot;</span> <span class="o">%</span> <span class="n">which</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">c</span>


<span class="k">class</span> <span class="nc">Error</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">FormatError</span><span class="p">(</span><span class="n">Error</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Problem with input file format.  In other words, PNG file does</span>
<span class="sd">    not conform to the specification in some way and is invalid.</span>
<span class="sd">    &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">ChunkError</span><span class="p">(</span><span class="n">FormatError</span><span class="p">):</span>
    <span class="k">pass</span>


<div class="viewcode-block" id="Writer"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Writer">[docs]</a><span class="k">class</span> <span class="nc">Writer</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    PNG encoder in pure Python.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Writer.__init__"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Writer.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">height</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">greyscale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">bitdepth</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
            <span class="n">palette</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">transparent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">background</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">gamma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">compression</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">interlace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">bytes_per_sample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># deprecated</span>
            <span class="n">planes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">colormap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">maxval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">chunk_limit</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="mi">20</span><span class="p">,</span>
            <span class="n">x_pixels_per_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">y_pixels_per_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">unit_is_meter</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a PNG encoder object.</span>

<span class="sd">        Arguments:</span>

<span class="sd">        width, height</span>
<span class="sd">          Image size in pixels, as two separate arguments.</span>
<span class="sd">        size</span>
<span class="sd">          Image size (w,h) in pixels, as single argument.</span>
<span class="sd">        greyscale</span>
<span class="sd">          Input data is greyscale, not RGB.</span>
<span class="sd">        alpha</span>
<span class="sd">          Input data has alpha channel (RGBA or LA).</span>
<span class="sd">        bitdepth</span>
<span class="sd">          Bit depth: from 1 to 16.</span>
<span class="sd">        palette</span>
<span class="sd">          Create a palette for a colour mapped image (colour type 3).</span>
<span class="sd">        transparent</span>
<span class="sd">          Specify a transparent colour (create a ``tRNS`` chunk).</span>
<span class="sd">        background</span>
<span class="sd">          Specify a default background colour (create a ``bKGD`` chunk).</span>
<span class="sd">        gamma</span>
<span class="sd">          Specify a gamma value (create a ``gAMA`` chunk).</span>
<span class="sd">        compression</span>
<span class="sd">          zlib compression level: 0 (none) to 9 (more compressed);</span>
<span class="sd">          default: -1 or None.</span>
<span class="sd">        interlace</span>
<span class="sd">          Create an interlaced image.</span>
<span class="sd">        chunk_limit</span>
<span class="sd">          Write multiple ``IDAT`` chunks to save memory.</span>
<span class="sd">        x_pixels_per_unit</span>
<span class="sd">          Number of pixels a unit along the x axis (write a</span>
<span class="sd">          `pHYs` chunk).</span>
<span class="sd">        y_pixels_per_unit</span>
<span class="sd">          Number of pixels a unit along the y axis (write a</span>
<span class="sd">          `pHYs` chunk). Along with `x_pixel_unit`, this gives</span>
<span class="sd">          the pixel size ratio.</span>
<span class="sd">        unit_is_meter</span>
<span class="sd">          `True` to indicate that the unit (for the `pHYs`</span>
<span class="sd">          chunk) is metre.</span>

<span class="sd">        The image size (in pixels) can be specified either by using the</span>
<span class="sd">        `width` and `height` arguments, or with the single `size`</span>
<span class="sd">        argument.  If `size` is used it should be a pair (*width*,</span>
<span class="sd">        *height*).</span>

<span class="sd">        `greyscale` and `alpha` are booleans that specify whether</span>
<span class="sd">        an image is greyscale (or colour), and whether it has an</span>
<span class="sd">        alpha channel (or not).</span>

<span class="sd">        `bitdepth` specifies the bit depth of the source pixel values.</span>
<span class="sd">        Each source pixel value must be an integer between 0 and</span>
<span class="sd">        ``2**bitdepth-1``.  For example, 8-bit images have values</span>
<span class="sd">        between 0 and 255.  PNG only stores images with bit depths of</span>
<span class="sd">        1,2,4,8, or 16.  When `bitdepth` is not one of these values,</span>
<span class="sd">        the next highest valid bit depth is selected, and an ``sBIT``</span>
<span class="sd">        (significant bits) chunk is generated that specifies the</span>
<span class="sd">        original precision of the source image.  In this case the</span>
<span class="sd">        supplied pixel values will be rescaled to fit the range of</span>
<span class="sd">        the selected bit depth.</span>

<span class="sd">        The details of which bit depth / colour model combinations the</span>
<span class="sd">        PNG file format supports directly, are somewhat arcane</span>
<span class="sd">        (refer to the PNG specification for full details).  Briefly:</span>
<span class="sd">        &quot;small&quot; bit depths (1,2,4) are only allowed with greyscale and</span>
<span class="sd">        colour mapped images; colour mapped images cannot have bit depth</span>
<span class="sd">        16.</span>

<span class="sd">        For colour mapped images (in other words, when the `palette`</span>
<span class="sd">        argument is specified) the `bitdepth` argument must match one of</span>
<span class="sd">        the valid PNG bit depths: 1, 2, 4, or 8.  (It is valid to have a</span>
<span class="sd">        PNG image with a palette and an ``sBIT`` chunk, but the meaning</span>
<span class="sd">        is slightly different; it would be awkward to press the</span>
<span class="sd">        `bitdepth` argument into service for this.)</span>

<span class="sd">        The `palette` option, when specified, causes a colour</span>
<span class="sd">        mapped image to be created: the PNG colour type is set to 3;</span>
<span class="sd">        `greyscale` must not be set; `alpha` must not be set;</span>
<span class="sd">        `transparent` must not be set; the bit depth must be 1,2,4,</span>
<span class="sd">        or 8.  When a colour mapped image is created, the pixel values</span>
<span class="sd">        are palette indexes and the `bitdepth` argument specifies the</span>
<span class="sd">        size of these indexes (not the size of the colour values in</span>
<span class="sd">        the palette).</span>

<span class="sd">        The palette argument value should be a sequence of 3- or</span>
<span class="sd">        4-tuples.  3-tuples specify RGB palette entries; 4-tuples</span>
<span class="sd">        specify RGBA palette entries.  If both 4-tuples and 3-tuples</span>
<span class="sd">        appear in the sequence then all the 4-tuples must come</span>
<span class="sd">        before all the 3-tuples.  A ``PLTE`` chunk is created; if there</span>
<span class="sd">        are 4-tuples then a ``tRNS`` chunk is created as well.  The</span>
<span class="sd">        ``PLTE`` chunk will contain all the RGB triples in the same</span>
<span class="sd">        sequence; the ``tRNS`` chunk will contain the alpha channel for</span>
<span class="sd">        all the 4-tuples, in the same sequence.  Palette entries</span>
<span class="sd">        are always 8-bit.</span>

<span class="sd">        If specified, the `transparent` and `background` parameters must</span>
<span class="sd">        be a tuple with three integer values for red, green, blue, or</span>
<span class="sd">        a simple integer (or singleton tuple) for a greyscale image.</span>

<span class="sd">        If specified, the `gamma` parameter must be a positive number</span>
<span class="sd">        (generally, a `float`).  A ``gAMA`` chunk will be created.</span>
<span class="sd">        Note that this will not change the values of the pixels as</span>
<span class="sd">        they appear in the PNG file, they are assumed to have already</span>
<span class="sd">        been converted appropriately for the gamma specified.</span>

<span class="sd">        The `compression` argument specifies the compression level to</span>
<span class="sd">        be used by the ``zlib`` module.  Values from 1 to 9 specify</span>
<span class="sd">        compression, with 9 being &quot;more compressed&quot; (usually smaller</span>
<span class="sd">        and slower, but it doesn&#39;t always work out that way).  0 means</span>
<span class="sd">        no compression.  -1 and ``None`` both mean that the default</span>
<span class="sd">        level of compession will be picked by the ``zlib`` module</span>
<span class="sd">        (which is generally acceptable).</span>

<span class="sd">        If `interlace` is true then an interlaced image is created</span>
<span class="sd">        (using PNG&#39;s so far only interace method, *Adam7*).  This does</span>
<span class="sd">        not affect how the pixels should be presented to the encoder,</span>
<span class="sd">        rather it changes how they are arranged into the PNG file.</span>
<span class="sd">        On slow connexions interlaced images can be partially decoded</span>
<span class="sd">        by the browser to give a rough view of the image that is</span>
<span class="sd">        successively refined as more image data appears.</span>

<span class="sd">        .. note ::</span>

<span class="sd">          Enabling the `interlace` option requires the entire image</span>
<span class="sd">          to be processed in working memory.</span>

<span class="sd">        `chunk_limit` is used to limit the amount of memory used whilst</span>
<span class="sd">        compressing the image.  In order to avoid using large amounts of</span>
<span class="sd">        memory, multiple ``IDAT`` chunks may be created.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># At the moment the `planes` argument is ignored;</span>
        <span class="c1"># its purpose is to act as a dummy so that</span>
        <span class="c1"># ``Writer(x, y, **info)`` works, where `info` is a dictionary</span>
        <span class="c1"># returned by Reader.read and friends.</span>
        <span class="c1"># Ditto for `colormap`.</span>

        <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">check_sizes</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">size</span>

        <span class="k">if</span> <span class="n">width</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">height</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;width and height must be greater than zero&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isinteger</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">isinteger</span><span class="p">(</span><span class="n">height</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;width and height must be integers&quot;</span><span class="p">)</span>
        <span class="c1"># http://www.w3.org/TR/PNG/#7Integers-and-byte-order</span>
        <span class="k">if</span> <span class="n">width</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">height</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;width and height cannot exceed 2**32-1&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">alpha</span> <span class="ow">and</span> <span class="n">transparent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;transparent colour not allowed with alpha channel&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bytes_per_sample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;please use bitdepth instead of bytes_per_sample&#39;</span><span class="p">,</span>
                          <span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bytes_per_sample</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mf">0.125</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;bytes per sample must be .125, .25, .5, 1, or 2&quot;</span><span class="p">)</span>
            <span class="n">bitdepth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="n">bytes_per_sample</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">bytes_per_sample</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isinteger</span><span class="p">(</span><span class="n">bitdepth</span><span class="p">)</span> <span class="ow">or</span> <span class="n">bitdepth</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="mi">16</span> <span class="o">&lt;</span> <span class="n">bitdepth</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bitdepth (</span><span class="si">%r</span><span class="s2">) must be a positive integer &lt;= 16&quot;</span> <span class="o">%</span>
                             <span class="n">bitdepth</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">palette</span> <span class="o">=</span> <span class="n">check_palette</span><span class="p">(</span><span class="n">palette</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">palette</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bitdepth</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;with palette, bitdepth must be 1, 2, 4, or 8&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">transparent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transparent and palette not compatible&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">alpha</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;alpha and palette not compatible&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">greyscale</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;greyscale and palette not compatible&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># No palette, check for sBIT chunk generation.</span>
            <span class="k">if</span> <span class="n">alpha</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">greyscale</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">bitdepth</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">):</span>
                    <span class="n">targetbitdepth</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">)[</span><span class="n">bitdepth</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span> <span class="o">=</span> <span class="p">(</span><span class="n">bitdepth</span><span class="p">,</span> <span class="n">targetbitdepth</span><span class="p">)</span>
                    <span class="n">bitdepth</span> <span class="o">=</span> <span class="n">targetbitdepth</span>
                    <span class="k">del</span> <span class="n">targetbitdepth</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">greyscale</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">alpha</span>
                <span class="k">if</span> <span class="n">bitdepth</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">bitdepth</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">:</span>
                        <span class="n">targetbitdepth</span> <span class="o">=</span> <span class="mi">16</span>
                    <span class="k">elif</span> <span class="n">bitdepth</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="n">targetbitdepth</span> <span class="o">=</span> <span class="mi">4</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="n">bitdepth</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
                        <span class="n">targetbitdepth</span> <span class="o">=</span> <span class="mi">8</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span> <span class="o">=</span> <span class="p">(</span><span class="n">bitdepth</span><span class="p">,</span> <span class="n">targetbitdepth</span><span class="p">)</span>
                    <span class="n">bitdepth</span> <span class="o">=</span> <span class="n">targetbitdepth</span>
                    <span class="k">del</span> <span class="n">targetbitdepth</span>

        <span class="k">if</span> <span class="n">bitdepth</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="ow">and</span> <span class="p">(</span><span class="n">alpha</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">greyscale</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">palette</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;bitdepth &lt; 8 only permitted with greyscale or palette&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bitdepth</span> <span class="o">&gt;</span> <span class="mi">8</span> <span class="ow">and</span> <span class="n">palette</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;bit depth must be 8 or less for images with palette&quot;</span><span class="p">)</span>

        <span class="n">transparent</span> <span class="o">=</span> <span class="n">check_color</span><span class="p">(</span><span class="n">transparent</span><span class="p">,</span> <span class="n">greyscale</span><span class="p">,</span> <span class="s1">&#39;transparent&#39;</span><span class="p">)</span>
        <span class="n">background</span> <span class="o">=</span> <span class="n">check_color</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="n">greyscale</span><span class="p">,</span> <span class="s1">&#39;background&#39;</span><span class="p">)</span>

        <span class="c1"># It&#39;s important that the true boolean values (greyscale, alpha,</span>
        <span class="c1"># colormap, interlace) are converted to bool because Iverson&#39;s</span>
        <span class="c1"># convention is relied upon later on.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transparent</span> <span class="o">=</span> <span class="n">transparent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">background</span> <span class="o">=</span> <span class="n">background</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">greyscale</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">greyscale</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colormap</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">palette</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bitdepth</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compression</span> <span class="o">=</span> <span class="n">compression</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chunk_limit</span> <span class="o">=</span> <span class="n">chunk_limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interlace</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">interlace</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">palette</span> <span class="o">=</span> <span class="n">palette</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_pixels_per_unit</span> <span class="o">=</span> <span class="n">x_pixels_per_unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_pixels_per_unit</span> <span class="o">=</span> <span class="n">y_pixels_per_unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit_is_meter</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">unit_is_meter</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">color_type</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">greyscale</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">colormap</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">color_type</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">color_planes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">greyscale</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">colormap</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">planes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">color_planes</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>
        <span class="c1"># :todo: fix for bitdepth &lt; 8</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psize</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">planes</span></div>

<div class="viewcode-block" id="Writer.make_palette"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Writer.make_palette">[docs]</a>    <span class="k">def</span> <span class="nf">make_palette</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create the byte sequences for a ``PLTE`` and if necessary a</span>
<span class="sd">        ``tRNS`` chunk.  Returned as a pair (*p*, *t*).  *t* will be</span>
<span class="sd">        ``None`` if no ``tRNS`` chunk is necessary.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">palette</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">tostring</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">tostring</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">t</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Writer.write"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Writer.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="p">,</span> <span class="n">rows</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write a PNG image to the output file.  `rows` should be</span>
<span class="sd">        an iterable that yields each row in boxed row flat pixel</span>
<span class="sd">        format.  The rows should be the rows of the original image,</span>
<span class="sd">        so there should be ``self.height`` rows of ``self.width *</span>
<span class="sd">        self.planes`` values.  If `interlace` is specified (when</span>
<span class="sd">        creating the instance), then an interlaced PNG file will</span>
<span class="sd">        be written.  Supply the rows in the normal image order;</span>
<span class="sd">        the interlacing is carried out internally.</span>

<span class="sd">        .. note ::</span>

<span class="sd">          Interlacing will require the entire image to be in working</span>
<span class="sd">          memory.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interlace</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;BH&#39;</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">]</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">rows</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_array</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

        <span class="n">nrows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_passes</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">rows</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nrows</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;rows supplied (</span><span class="si">%d</span><span class="s2">) does not match height (</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">))</span></div>

<div class="viewcode-block" id="Writer.write_passes"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Writer.write_passes">[docs]</a>    <span class="k">def</span> <span class="nf">write_passes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">packed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write a PNG image to the output file.</span>

<span class="sd">        Most users are expected to find the :meth:`write` or</span>
<span class="sd">        :meth:`write_array` method more convenient.</span>

<span class="sd">        The rows should be given to this method in the order that</span>
<span class="sd">        they appear in the output file.  For straightlaced images,</span>
<span class="sd">        this is the usual top to bottom ordering, but for interlaced</span>
<span class="sd">        images the rows should have already been interlaced before</span>
<span class="sd">        passing them to this function.</span>

<span class="sd">        `rows` should be an iterable that yields each row.  When</span>
<span class="sd">        `packed` is ``False`` the rows should be in boxed row flat pixel</span>
<span class="sd">        format; when `packed` is ``True`` each row should be a packed</span>
<span class="sd">        sequence of bytes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># http://www.w3.org/TR/PNG/#5PNG-file-signature</span>
        <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">_signature</span><span class="p">)</span>

        <span class="c1"># http://www.w3.org/TR/PNG/#11IHDR</span>
        <span class="n">write_chunk</span><span class="p">(</span>
            <span class="n">outfile</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;IHDR&#39;</span><span class="p">,</span>
            <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;!2I5B&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">color_type</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">interlace</span><span class="p">))</span>

        <span class="c1"># See :chunk:order</span>
        <span class="c1"># http://www.w3.org/TR/PNG/#11gAMA</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">write_chunk</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;gAMA&#39;</span><span class="p">,</span>
                        <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;!L&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">*</span> <span class="mf">1e5</span><span class="p">))))</span>

        <span class="c1"># See :chunk:order</span>
        <span class="c1"># http://www.w3.org/TR/PNG/#11sBIT</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span><span class="p">:</span>
            <span class="n">write_chunk</span><span class="p">(</span>
                <span class="n">outfile</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;sBIT&#39;</span><span class="p">,</span>
                <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">B&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">planes</span><span class="p">,</span>
                            <span class="o">*</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rescale</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">planes</span><span class="p">))</span>

        <span class="c1"># :chunk:order: Without a palette (PLTE chunk), ordering is</span>
        <span class="c1"># relatively relaxed.  With one, gAMA chunk must precede PLTE</span>
        <span class="c1"># chunk which must precede tRNS and bKGD.</span>
        <span class="c1"># See http://www.w3.org/TR/PNG/#5ChunkOrdering</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">palette</span><span class="p">:</span>
            <span class="n">p</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_palette</span><span class="p">()</span>
            <span class="n">write_chunk</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;PLTE&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">t</span><span class="p">:</span>
                <span class="c1"># tRNS chunk is optional. Only needed if palette entries</span>
                <span class="c1"># have alpha.</span>
                <span class="n">write_chunk</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;tRNS&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

        <span class="c1"># http://www.w3.org/TR/PNG/#11tRNS</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transparent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">greyscale</span><span class="p">:</span>
                <span class="n">write_chunk</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;tRNS&#39;</span><span class="p">,</span>
                            <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;!1H&quot;</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">transparent</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">write_chunk</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;tRNS&#39;</span><span class="p">,</span>
                            <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;!3H&quot;</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">transparent</span><span class="p">))</span>

        <span class="c1"># http://www.w3.org/TR/PNG/#11bKGD</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">background</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">greyscale</span><span class="p">:</span>
                <span class="n">write_chunk</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;bKGD&#39;</span><span class="p">,</span>
                            <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;!1H&quot;</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">write_chunk</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;bKGD&#39;</span><span class="p">,</span>
                            <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;!3H&quot;</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="p">))</span>

        <span class="c1"># http://www.w3.org/TR/PNG/#11pHYs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_pixels_per_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_pixels_per_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tup</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_pixels_per_unit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_pixels_per_unit</span><span class="p">,</span>
                   <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit_is_meter</span><span class="p">))</span>
            <span class="n">write_chunk</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;pHYs&#39;</span><span class="p">,</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;!LLB&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">tup</span><span class="p">))</span>

        <span class="c1"># http://www.w3.org/TR/PNG/#11IDAT</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compression</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">compressor</span> <span class="o">=</span> <span class="n">zlib</span><span class="o">.</span><span class="n">compressobj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compression</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">compressor</span> <span class="o">=</span> <span class="n">zlib</span><span class="o">.</span><span class="n">compressobj</span><span class="p">()</span>

        <span class="c1"># Choose an extend function based on the bitdepth.  The extend</span>
        <span class="c1"># function packs/decomposes the pixel values into bytes and</span>
        <span class="c1"># stuffs them onto the data array.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span> <span class="o">==</span> <span class="mi">8</span> <span class="ow">or</span> <span class="n">packed</span><span class="p">:</span>
            <span class="n">extend</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">extend</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span> <span class="o">==</span> <span class="mi">16</span><span class="p">:</span>
            <span class="c1"># Decompose into bytes</span>
            <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="n">sl</span><span class="p">):</span>
                <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;!</span><span class="si">%d</span><span class="s1">H&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>
                <span class="n">data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="o">*</span><span class="n">sl</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Pack into bytes</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span> <span class="o">&lt;</span> <span class="mi">8</span>
            <span class="c1"># samples per byte</span>
            <span class="n">spb</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">8</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="n">sl</span><span class="p">):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">sl</span><span class="p">)</span>
                <span class="c1"># Adding padding bytes so we can group into a whole</span>
                <span class="c1"># number of spb-tuples.</span>
                <span class="n">l</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
                <span class="n">extra</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">l</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">spb</span><span class="p">))</span> <span class="o">*</span> <span class="n">spb</span> <span class="o">-</span> <span class="n">l</span>
                <span class="n">a</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">extra</span><span class="p">))</span>
                <span class="c1"># Pack into bytes</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">group</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">spb</span><span class="p">)</span>
                <span class="n">l</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">l</span>
                <span class="p">]</span>
                <span class="n">data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span><span class="p">:</span>
            <span class="n">oldextend</span> <span class="o">=</span> <span class="n">extend</span>
            <span class="n">factor</span> <span class="o">=</span> \
              <span class="nb">float</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">rescale</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">rescale</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="n">sl</span><span class="p">):</span>
                <span class="n">oldextend</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">factor</span> <span class="o">*</span> <span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sl</span><span class="p">])</span>

        <span class="c1"># Build the first row, testing mostly to see if we need to</span>
        <span class="c1"># changed the extend function to cope with NumPy integer types</span>
        <span class="c1"># (they cause our ordinary definition of extend to fail, so we</span>
        <span class="c1"># wrap it).  See</span>
        <span class="c1"># http://code.google.com/p/pypng/issues/detail?id=44</span>
        <span class="n">enumrows</span> <span class="o">=</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">rows</span>

        <span class="c1"># First row&#39;s filter type.</span>
        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># :todo: Certain exceptions in the call to ``.next()`` or the</span>
        <span class="c1"># following try would indicate no row data supplied.</span>
        <span class="c1"># Should catch.</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">enumrows</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># If this fails...</span>
            <span class="n">extend</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c1"># ... try a version that converts the values to int first.</span>
            <span class="c1"># Not only does this work for the (slightly broken) NumPy</span>
            <span class="c1"># types, there are probably lots of other, unknown, &quot;nearly&quot;</span>
            <span class="c1"># int types it works for.</span>
            <span class="k">def</span> <span class="nf">wrapmapint</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                <span class="k">return</span> <span class="k">lambda</span> <span class="n">sl</span><span class="p">:</span> <span class="n">f</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sl</span><span class="p">])</span>

            <span class="n">extend</span> <span class="o">=</span> <span class="n">wrapmapint</span><span class="p">(</span><span class="n">extend</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">wrapmapint</span>
            <span class="n">extend</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">enumrows</span><span class="p">:</span>
            <span class="c1"># Add &quot;None&quot; filter type.  Currently, it&#39;s essential that</span>
            <span class="c1"># this filter type be used for every scanline as we do not</span>
            <span class="c1"># mark the first row of a reduced pass image; that means we</span>
            <span class="c1"># could accidentally compute the wrong filtered scanline if</span>
            <span class="c1"># we used &quot;up&quot;, &quot;average&quot;, or &quot;paeth&quot; on such a line.</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">extend</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_limit</span><span class="p">:</span>
                <span class="n">compressed</span> <span class="o">=</span> <span class="n">compressor</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">tostring</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">compressed</span><span class="p">):</span>
                    <span class="n">write_chunk</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;IDAT&#39;</span><span class="p">,</span> <span class="n">compressed</span><span class="p">)</span>
                <span class="c1"># Because of our very witty definition of ``extend``,</span>
                <span class="c1"># above, we must re-use the same ``data`` object.  Hence</span>
                <span class="c1"># we use ``del`` to empty this one, rather than create a</span>
                <span class="c1"># fresh one (which would be my natural FP instinct).</span>
                <span class="k">del</span> <span class="n">data</span><span class="p">[:]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="n">compressed</span> <span class="o">=</span> <span class="n">compressor</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">tostring</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">compressed</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span>
        <span class="n">flushed</span> <span class="o">=</span> <span class="n">compressor</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">compressed</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">flushed</span><span class="p">):</span>
            <span class="n">write_chunk</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;IDAT&#39;</span><span class="p">,</span> <span class="n">compressed</span> <span class="o">+</span> <span class="n">flushed</span><span class="p">)</span>
        <span class="c1"># http://www.w3.org/TR/PNG/#11IEND</span>
        <span class="n">write_chunk</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;IEND&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="Writer.write_array"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Writer.write_array">[docs]</a>    <span class="k">def</span> <span class="nf">write_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="p">,</span> <span class="n">pixels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write an array in flat row flat pixel format as a PNG file on</span>
<span class="sd">        the output file.  See also :meth:`write` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interlace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_passes</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_scanlines_interlace</span><span class="p">(</span><span class="n">pixels</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_passes</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_scanlines</span><span class="p">(</span><span class="n">pixels</span><span class="p">))</span></div>

<div class="viewcode-block" id="Writer.write_packed"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Writer.write_packed">[docs]</a>    <span class="k">def</span> <span class="nf">write_packed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="p">,</span> <span class="n">rows</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write PNG file to `outfile`.  The pixel data comes from `rows`</span>
<span class="sd">        which should be in boxed row packed format.  Each row should be</span>
<span class="sd">        a sequence of packed bytes.</span>

<span class="sd">        Technically, this method does work for interlaced images but it</span>
<span class="sd">        is best avoided.  For interlaced images, the rows should be</span>
<span class="sd">        presented in the order that they appear in the file.</span>

<span class="sd">        This method should not be used when the source image bit depth</span>
<span class="sd">        is not one naturally supported by PNG; the bit depth should be</span>
<span class="sd">        1, 2, 4, 8, or 16.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Error</span><span class="p">(</span><span class="s2">&quot;write_packed method not suitable for bit depth </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_passes</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">packed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Writer.convert_pnm"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Writer.convert_pnm">[docs]</a>    <span class="k">def</span> <span class="nf">convert_pnm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">infile</span><span class="p">,</span> <span class="n">outfile</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a PNM file containing raw pixel data into a PNG file</span>
<span class="sd">        with the parameters set in the writer object.  Works for</span>
<span class="sd">        (binary) PGM, PPM, and PAM formats.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interlace</span><span class="p">:</span>
            <span class="n">pixels</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
            <span class="n">pixels</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">infile</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">color_planes</span> <span class="o">*</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_passes</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_scanlines_interlace</span><span class="p">(</span><span class="n">pixels</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_passes</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_scanlines</span><span class="p">(</span><span class="n">infile</span><span class="p">))</span></div>

<div class="viewcode-block" id="Writer.convert_ppm_and_pgm"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Writer.convert_ppm_and_pgm">[docs]</a>    <span class="k">def</span> <span class="nf">convert_ppm_and_pgm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ppmfile</span><span class="p">,</span> <span class="n">pgmfile</span><span class="p">,</span> <span class="n">outfile</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a PPM and PGM file containing raw pixel data into a</span>
<span class="sd">        PNG outfile with the parameters set in the writer object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pixels</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
        <span class="n">pixels</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">ppmfile</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">color_planes</span> <span class="o">*</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">)</span>
        <span class="n">apixels</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
        <span class="n">apixels</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">pgmfile</span><span class="p">,</span>
                         <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">)</span>
        <span class="n">pixels</span> <span class="o">=</span> <span class="n">interleave_planes</span><span class="p">(</span><span class="n">pixels</span><span class="p">,</span> <span class="n">apixels</span><span class="p">,</span>
                                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">color_planes</span><span class="p">,</span>
                                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span> <span class="o">/</span> <span class="mi">8</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interlace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_passes</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_scanlines_interlace</span><span class="p">(</span><span class="n">pixels</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_passes</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_scanlines</span><span class="p">(</span><span class="n">pixels</span><span class="p">))</span></div>

<div class="viewcode-block" id="Writer.file_scanlines"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Writer.file_scanlines">[docs]</a>    <span class="k">def</span> <span class="nf">file_scanlines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">infile</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates boxed rows in flat pixel format, from the input file</span>
<span class="sd">        `infile`.  It assumes that the input file is in a &quot;Netpbm-like&quot;</span>
<span class="sd">        binary format, and is positioned at the beginning of the first</span>
<span class="sd">        pixel.  The number of pixels to read is taken from the image</span>
<span class="sd">        dimensions (`width`, `height`, `planes`) and the number of bytes</span>
<span class="sd">        per value is implied by the image `bitdepth`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Values per row</span>
        <span class="n">vpr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">planes</span>
        <span class="n">row_bytes</span> <span class="o">=</span> <span class="n">vpr</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span> <span class="o">==</span> <span class="mi">16</span>
            <span class="n">row_bytes</span> <span class="o">*=</span> <span class="mi">2</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;&gt;</span><span class="si">%d</span><span class="s1">H&#39;</span> <span class="o">%</span> <span class="n">vpr</span>

            <span class="k">def</span> <span class="nf">line</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">infile</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">row_bytes</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">line</span><span class="p">():</span>
                <span class="n">scanline</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">infile</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">row_bytes</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">scanline</span>

        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">line</span><span class="p">()</span></div>

<div class="viewcode-block" id="Writer.array_scanlines"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Writer.array_scanlines">[docs]</a>    <span class="k">def</span> <span class="nf">array_scanlines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates boxed rows (flat pixels) from flat rows (flat pixels)</span>
<span class="sd">        in an array.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Values per row</span>
        <span class="n">vpr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">planes</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">stop</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">vpr</span>
            <span class="k">yield</span> <span class="n">pixels</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span></div>

<div class="viewcode-block" id="Writer.array_scanlines_interlace"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Writer.array_scanlines_interlace">[docs]</a>    <span class="k">def</span> <span class="nf">array_scanlines_interlace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generator for interlaced scanlines from an array.  `pixels` is</span>
<span class="sd">        the full source image in flat row flat pixel format.  The</span>
<span class="sd">        generator yields each scanline of the reduced passes in turn, in</span>
<span class="sd">        boxed row flat pixel format.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># http://www.w3.org/TR/PNG/#8InterlaceMethods</span>
        <span class="c1"># Array type.</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;BH&#39;</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">]</span>
        <span class="c1"># Value per row</span>
        <span class="n">vpr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">planes</span>
        <span class="k">for</span> <span class="n">xstart</span><span class="p">,</span> <span class="n">ystart</span><span class="p">,</span> <span class="n">xstep</span><span class="p">,</span> <span class="n">ystep</span> <span class="ow">in</span> <span class="n">_adam7</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">xstart</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># Pixels per row (of reduced image)</span>
            <span class="n">ppr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="n">xstart</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">xstep</span><span class="p">)))</span>
            <span class="c1"># number of values in reduced image row.</span>
            <span class="n">row_len</span> <span class="o">=</span> <span class="n">ppr</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">planes</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ystart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">ystep</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">xstep</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">vpr</span>
                    <span class="k">yield</span> <span class="n">pixels</span><span class="p">[</span><span class="n">offset</span><span class="p">:</span><span class="n">offset</span> <span class="o">+</span> <span class="n">vpr</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">row</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">fmt</span><span class="p">)</span>
                    <span class="c1"># There&#39;s no easier way to set the length of an array</span>
                    <span class="n">row</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pixels</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">row_len</span><span class="p">])</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">vpr</span> <span class="o">+</span> <span class="n">xstart</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">planes</span>
                    <span class="n">end_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">vpr</span>
                    <span class="n">skip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">planes</span> <span class="o">*</span> <span class="n">xstep</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">planes</span><span class="p">):</span>
                        <span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">::</span><span class="bp">self</span><span class="o">.</span><span class="n">planes</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="n">pixels</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">i</span><span class="p">:</span><span class="n">end_offset</span><span class="p">:</span><span class="n">skip</span><span class="p">]</span>
                    <span class="k">yield</span> <span class="n">row</span></div></div>


<span class="k">def</span> <span class="nf">write_chunk</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Write a PNG chunk to the output file, including length and</span>
<span class="sd">    checksum.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># http://www.w3.org/TR/PNG/#5Chunk-layout</span>
    <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;!I&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>
    <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
    <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">checksum</span> <span class="o">=</span> <span class="n">zlib</span><span class="o">.</span><span class="n">crc32</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
    <span class="n">checksum</span> <span class="o">=</span> <span class="n">zlib</span><span class="o">.</span><span class="n">crc32</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">checksum</span><span class="p">)</span>
    <span class="n">checksum</span> <span class="o">&amp;=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;!I&quot;</span><span class="p">,</span> <span class="n">checksum</span><span class="p">))</span>


<div class="viewcode-block" id="write_chunks"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.write_chunks">[docs]</a><span class="k">def</span> <span class="nf">write_chunks</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">chunks</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a PNG file by writing out the chunks.&quot;&quot;&quot;</span>

    <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">_signature</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">:</span>
        <span class="n">write_chunk</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">filter_scanline</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">fo</span><span class="p">,</span> <span class="n">prev</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply a scanline filter to a scanline.  `type` specifies the</span>
<span class="sd">    filter type (0 to 4); `line` specifies the current (unfiltered)</span>
<span class="sd">    scanline as a sequence of bytes; `prev` specifies the previous</span>
<span class="sd">    (unfiltered) scanline as a sequence of bytes. `fo` specifies the</span>
<span class="sd">    filter offset; normally this is size of a pixel in bytes (the number</span>
<span class="sd">    of bytes per sample times the number of channels), but when this is</span>
<span class="sd">    &lt; 1 (for bit depths &lt; 8) then the filter offset is 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="nb">type</span> <span class="o">&lt;</span> <span class="mi">5</span>

    <span class="c1"># The output array.  Which, pathetically, we extend one-byte at a</span>
    <span class="c1"># time (fortunately this is linear).</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="p">[</span><span class="nb">type</span><span class="p">])</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">prev</span><span class="p">:</span>
        <span class="c1"># We&#39;re on the first line.  Some of the filters can be reduced</span>
        <span class="c1"># to simpler cases which makes handling the line &quot;off the top&quot;</span>
        <span class="c1"># of the image simpler.  &quot;up&quot; becomes &quot;none&quot;; &quot;paeth&quot; becomes</span>
        <span class="c1"># &quot;left&quot; (non-trivial, but true). &quot;average&quot; needs to be handled</span>
        <span class="c1"># specially.</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># &quot;up&quot;</span>
            <span class="nb">type</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>  <span class="c1"># &quot;paeth&quot;</span>
            <span class="nb">type</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">sub</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">up</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">average</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># type == 4</span>
        <span class="n">paeth</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="c1"># Regex for decoding mode string</span>
<span class="n">RegexModeDecode</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;(LA?|RGBA?);?([0-9]*)&quot;</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>


<div class="viewcode-block" id="from_array"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.from_array">[docs]</a><span class="k">def</span> <span class="nf">from_array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="p">{}):</span>
    <span class="sd">&quot;&quot;&quot;Create a PNG :class:`Image` object from a 2- or 3-dimensional</span>
<span class="sd">    array.  One application of this function is easy PIL-style saving:</span>
<span class="sd">    ``png.from_array(pixels, &#39;L&#39;).save(&#39;foo.png&#39;)``.</span>

<span class="sd">    Unless they are specified using the *info* parameter, the PNG&#39;s</span>
<span class="sd">    height and width are taken from the array size.  For a 3 dimensional</span>
<span class="sd">    array the first axis is the height; the second axis is the width;</span>
<span class="sd">    and the third axis is the channel number.  Thus an RGB image that is</span>
<span class="sd">    16 pixels high and 8 wide will use an array that is 16x8x3.  For 2</span>
<span class="sd">    dimensional arrays the first axis is the height, but the second axis</span>
<span class="sd">    is ``width*channels``, so an RGB image that is 16 pixels high and 8</span>
<span class="sd">    wide will use a 2-dimensional array that is 16x24 (each row will be</span>
<span class="sd">    8*3 = 24 sample values).</span>

<span class="sd">    *mode* is a string that specifies the image colour format in a</span>
<span class="sd">    PIL-style mode.  It can be:</span>

<span class="sd">    ``&#39;L&#39;``</span>
<span class="sd">      greyscale (1 channel)</span>
<span class="sd">    ``&#39;LA&#39;``</span>
<span class="sd">      greyscale with alpha (2 channel)</span>
<span class="sd">    ``&#39;RGB&#39;``</span>
<span class="sd">      colour image (3 channel)</span>
<span class="sd">    ``&#39;RGBA&#39;``</span>
<span class="sd">      colour image with alpha (4 channel)</span>

<span class="sd">    The mode string can also specify the bit depth (overriding how this</span>
<span class="sd">    function normally derives the bit depth, see below).  Appending</span>
<span class="sd">    ``&#39;;16&#39;`` to the mode will cause the PNG to be 16 bits per channel;</span>
<span class="sd">    any decimal from 1 to 16 can be used to specify the bit depth.</span>

<span class="sd">    When a 2-dimensional array is used *mode* determines how many</span>
<span class="sd">    channels the image has, and so allows the width to be derived from</span>
<span class="sd">    the second array dimension.</span>

<span class="sd">    The array is expected to be a ``numpy`` array, but it can be any</span>
<span class="sd">    suitable Python sequence.  For example, a list of lists can be used:</span>
<span class="sd">    ``png.from_array([[0, 255, 0], [255, 0, 255]], &#39;L&#39;)``.  The exact</span>
<span class="sd">    rules are: ``len(a)`` gives the first dimension, height;</span>
<span class="sd">    ``len(a[0])`` gives the second dimension; ``len(a[0][0])`` gives the</span>
<span class="sd">    third dimension, unless an exception is raised in which case a</span>
<span class="sd">    2-dimensional array is assumed.  It&#39;s slightly more complicated than</span>
<span class="sd">    that because an iterator of rows can be used, and it all still</span>
<span class="sd">    works.  Using an iterator allows data to be streamed efficiently.</span>

<span class="sd">    The bit depth of the PNG is normally taken from the array element&#39;s</span>
<span class="sd">    datatype (but if *mode* specifies a bitdepth then that is used</span>
<span class="sd">    instead).  The array element&#39;s datatype is determined in a way which</span>
<span class="sd">    is supposed to work both for ``numpy`` arrays and for Python</span>
<span class="sd">    ``array.array`` objects.  A 1 byte datatype will give a bit depth of</span>
<span class="sd">    8, a 2 byte datatype will give a bit depth of 16.  If the datatype</span>
<span class="sd">    does not have an implicit size, for example it is a plain Python</span>
<span class="sd">    list of lists, as above, then a default of 8 is used.</span>

<span class="sd">    The *info* parameter is a dictionary that can be used to specify</span>
<span class="sd">    metadata (in the same style as the arguments to the</span>
<span class="sd">    :class:`png.Writer` class).  For this function the keys that are</span>
<span class="sd">    useful are:</span>

<span class="sd">    height</span>
<span class="sd">      overrides the height derived from the array dimensions and allows</span>
<span class="sd">      *a* to be an iterable.</span>
<span class="sd">    width</span>
<span class="sd">      overrides the width derived from the array dimensions.</span>
<span class="sd">    bitdepth</span>
<span class="sd">      overrides the bit depth derived from the element datatype (but</span>
<span class="sd">      must match *mode* if that also specifies a bit depth).</span>

<span class="sd">    Generally anything specified in the</span>
<span class="sd">    *info* dictionary will override any implicit choices that this</span>
<span class="sd">    function would otherwise make, but must match any explicit ones.</span>
<span class="sd">    For example, if the *info* dictionary has a ``greyscale`` key then</span>
<span class="sd">    this must be true when mode is ``&#39;L&#39;`` or ``&#39;LA&#39;`` and false when</span>
<span class="sd">    mode is ``&#39;RGB&#39;`` or ``&#39;RGBA&#39;``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># We abuse the *info* parameter by modifying it.  Take a copy here.</span>
    <span class="c1"># (Also typechecks *info* to some extent).</span>
    <span class="n">info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

    <span class="c1"># Syntax check mode string.</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">RegexModeDecode</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">Error</span><span class="p">(</span><span class="s2">&quot;mode string should be &#39;RGB&#39; or &#39;L;16&#39; or similar.&quot;</span><span class="p">)</span>

    <span class="n">mode</span><span class="p">,</span> <span class="n">bitdepth</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="s1">&#39;A&#39;</span> <span class="ow">in</span> <span class="n">mode</span>
    <span class="k">if</span> <span class="n">bitdepth</span><span class="p">:</span>
        <span class="n">bitdepth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bitdepth</span><span class="p">)</span>

    <span class="c1"># Colour format.</span>
    <span class="k">if</span> <span class="s1">&#39;greyscale&#39;</span> <span class="ow">in</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;greyscale&#39;</span><span class="p">])</span> <span class="o">!=</span> <span class="p">(</span><span class="s1">&#39;L&#39;</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Error</span><span class="p">(</span><span class="s2">&quot;info[&#39;greyscale&#39;] should match mode.&quot;</span><span class="p">)</span>
    <span class="n">info</span><span class="p">[</span><span class="s1">&#39;greyscale&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;L&#39;</span> <span class="ow">in</span> <span class="n">mode</span>

    <span class="k">if</span> <span class="s1">&#39;alpha&#39;</span> <span class="ow">in</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">])</span> <span class="o">!=</span> <span class="n">alpha</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Error</span><span class="p">(</span><span class="s2">&quot;info[&#39;alpha&#39;] should match mode.&quot;</span><span class="p">)</span>
    <span class="n">info</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span>

    <span class="c1"># Get bitdepth from *mode* if possible.</span>
    <span class="k">if</span> <span class="n">bitdepth</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bitdepth&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">bitdepth</span> <span class="o">!=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;bitdepth&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">Error</span><span class="p">(</span><span class="s2">&quot;bitdepth (</span><span class="si">%d</span><span class="s2">) should match bitdepth of info (</span><span class="si">%d</span><span class="s2">).&quot;</span> <span class="o">%</span>
                        <span class="p">(</span><span class="n">bitdepth</span><span class="p">,</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;bitdepth&#39;</span><span class="p">]))</span>
        <span class="n">info</span><span class="p">[</span><span class="s1">&#39;bitdepth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bitdepth</span>

    <span class="c1"># Fill in and/or check entries in *info*.</span>
    <span class="c1"># Dimensions.</span>
    <span class="k">if</span> <span class="s1">&#39;size&#39;</span> <span class="ow">in</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;size&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span>

        <span class="c1"># Check width, height, size all match where used.</span>
        <span class="k">for</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">axis</span> <span class="ow">in</span> <span class="p">[(</span><span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]:</span>
            <span class="k">if</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="n">info</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">info</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">!=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">][</span><span class="n">axis</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="n">Error</span><span class="p">(</span><span class="s2">&quot;info[</span><span class="si">%r</span><span class="s2">] should match info[&#39;size&#39;][</span><span class="si">%r</span><span class="s2">].&quot;</span> <span class="o">%</span>
                                <span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="n">axis</span><span class="p">))</span>
        <span class="n">info</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="s1">&#39;height&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">info</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Error</span><span class="p">(</span><span class="s2">&quot;len(a) does not work, supply info[&#39;height&#39;] instead.&quot;</span><span class="p">)</span>

    <span class="n">planes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;planes&#39;</span> <span class="ow">in</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;planes&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">planes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Error</span><span class="p">(</span><span class="s2">&quot;info[&#39;planes&#39;] should match mode.&quot;</span><span class="p">)</span>

    <span class="c1"># In order to work out whether we the array is 2D or 3D we need its</span>
    <span class="c1"># first row, which requires that we take a copy of its iterator.</span>
    <span class="c1"># We may also need the first row to derive width and bitdepth.</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">tee</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">row</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">t</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">threed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">testelement</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="n">threed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">testelement</span> <span class="o">=</span> <span class="n">row</span>
    <span class="k">if</span> <span class="s1">&#39;width&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">threed</span><span class="p">:</span>
            <span class="n">width</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">width</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">//</span> <span class="n">planes</span>
        <span class="n">info</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">width</span>

    <span class="k">if</span> <span class="n">threed</span><span class="p">:</span>
        <span class="c1"># Flatten the threed rows</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;bitdepth&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">testelement</span><span class="o">.</span><span class="n">dtype</span>
            <span class="c1"># goto the &quot;else:&quot; clause.  Sorry.</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Try a Python array.array.</span>
                <span class="n">bitdepth</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">testelement</span><span class="o">.</span><span class="n">itemsize</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="c1"># We can&#39;t determine it from the array element&#39;s</span>
                <span class="c1"># datatype, use a default of 8.</span>
                <span class="n">bitdepth</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If we got here without exception, we now assume that</span>
            <span class="c1"># the array is a numpy array.</span>
            <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span>
                <span class="n">bitdepth</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bitdepth</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="n">info</span><span class="p">[</span><span class="s1">&#39;bitdepth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bitdepth</span>

    <span class="k">for</span> <span class="n">thing</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">,</span> <span class="s2">&quot;height&quot;</span><span class="p">,</span> <span class="s2">&quot;bitdepth&quot;</span><span class="p">,</span> <span class="s2">&quot;greyscale&quot;</span><span class="p">,</span> <span class="s2">&quot;alpha&quot;</span><span class="p">]:</span>
        <span class="k">assert</span> <span class="n">thing</span> <span class="ow">in</span> <span class="n">info</span>

    <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span></div>


<span class="c1"># So that refugee&#39;s from PIL feel more at home.  Not documented.</span>
<span class="n">fromarray</span> <span class="o">=</span> <span class="n">from_array</span>


<div class="viewcode-block" id="Image"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Image">[docs]</a><span class="k">class</span> <span class="nc">Image</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A PNG image.  You can create an :class:`Image` object from</span>
<span class="sd">    an array of pixels by calling :meth:`png.from_array`.  It can be</span>
<span class="sd">    saved to disk with the :meth:`save` method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Image.__init__"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Image.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">info</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. note ::</span>

<span class="sd">          The constructor is not public.  Please do not call it.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">=</span> <span class="n">rows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span></div>

<div class="viewcode-block" id="Image.save"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Image.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save the image to *file*.  If *file* looks like an open file</span>
<span class="sd">        descriptor then it is used, otherwise it is treated as a</span>
<span class="sd">        filename and a fresh file is opened.</span>

<span class="sd">        In general, you can only call this method once; after it has</span>
<span class="sd">        been called the first time and the PNG image has been saved, the</span>
<span class="sd">        source data will have been streamed, and cannot be streamed</span>
<span class="sd">        again.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">w</span> <span class="o">=</span> <span class="n">Writer</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span>

            <span class="k">def</span> <span class="nf">close</span><span class="p">():</span>
                <span class="k">pass</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">close</span><span class="p">():</span>
                <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">w</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">close</span><span class="p">()</span></div></div>


<span class="k">class</span> <span class="nc">_readable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A simple file-like interface for strings and arrays.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buf</span> <span class="o">=</span> <span class="n">buf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">isarray</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">tostring</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="k">return</span> <span class="n">r</span>


<span class="k">try</span><span class="p">:</span>
    <span class="nb">str</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;dummy&#39;</span><span class="p">,</span> <span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="n">as_str</span> <span class="o">=</span> <span class="nb">str</span>
<span class="k">else</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">as_str</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;ascii&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="Reader"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Reader">[docs]</a><span class="k">class</span> <span class="nc">Reader</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    PNG decoder in pure Python.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Reader.__init__"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Reader.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_guess</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a PNG decoder object.</span>

<span class="sd">        The constructor expects exactly one keyword argument. If you</span>
<span class="sd">        supply a positional argument instead, it will guess the input</span>
<span class="sd">        type. You can choose among the following keyword arguments:</span>

<span class="sd">        filename</span>
<span class="sd">          Name of input file (a PNG file).</span>
<span class="sd">        file</span>
<span class="sd">          A file-like object (object with a read() method).</span>
<span class="sd">        bytes</span>
<span class="sd">          ``array`` or ``string`` with PNG data.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">_guess</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">_guess</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Reader() takes exactly 1 argument&quot;</span><span class="p">)</span>

        <span class="c1"># Will be the first 8 bytes, later on.  See validate_signature.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">signature</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transparent</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># A pair of (len,type) if a chunk has been read but its data and</span>
        <span class="c1"># checksum have not (in other words the file position is just</span>
        <span class="c1"># past the 4 bytes that specify the chunk type).  See preamble</span>
        <span class="c1"># method for how this is used.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atchunk</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">_guess</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">isarray</span><span class="p">(</span><span class="n">_guess</span><span class="p">):</span>
                <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;bytes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_guess</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_guess</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;filename&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_guess</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">_guess</span><span class="p">,</span> <span class="s1">&#39;read&#39;</span><span class="p">):</span>
                <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;file&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_guess</span>

        <span class="k">if</span> <span class="s2">&quot;filename&quot;</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">kw</span><span class="p">[</span><span class="s2">&quot;filename&quot;</span><span class="p">],</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;file&quot;</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;file&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s2">&quot;bytes&quot;</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">_readable</span><span class="p">(</span><span class="n">kw</span><span class="p">[</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;expecting filename, file or bytes array&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Reader.chunk"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Reader.chunk">[docs]</a>    <span class="k">def</span> <span class="nf">chunk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seek</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lenient</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read the next PNG chunk from the input file; returns a</span>
<span class="sd">        (*type*, *data*) tuple.  *type* is the chunk&#39;s type as a</span>
<span class="sd">        byte string (all PNG chunk types are 4 bytes long).</span>
<span class="sd">        *data* is the chunk&#39;s data content, as a byte string.</span>

<span class="sd">        If the optional `seek` argument is</span>
<span class="sd">        specified then it will keep reading chunks until it either runs</span>
<span class="sd">        out of file or finds the type specified by the argument.  Note</span>
<span class="sd">        that in general the order of chunks in PNGs is unspecified, so</span>
<span class="sd">        using `seek` can cause you to miss chunks.</span>

<span class="sd">        If the optional `lenient` argument evaluates to `True`,</span>
<span class="sd">        checksum failures will raise warnings rather than exceptions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">validate_signature</span><span class="p">()</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># http://www.w3.org/TR/PNG/#5Chunk-layout</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">atchunk</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">atchunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunklentype</span><span class="p">()</span>
            <span class="n">length</span><span class="p">,</span> <span class="nb">type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atchunk</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atchunk</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="n">length</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ChunkError</span><span class="p">(</span><span class="s1">&#39;Chunk </span><span class="si">%s</span><span class="s1"> too short for required </span><span class="si">%i</span><span class="s1"> octets.&#39;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">length</span><span class="p">))</span>
            <span class="n">checksum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">checksum</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ChunkError</span><span class="p">(</span><span class="s1">&#39;Chunk </span><span class="si">%s</span><span class="s1"> too short for checksum.&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">seek</span> <span class="ow">and</span> <span class="nb">type</span> <span class="o">!=</span> <span class="n">seek</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">verify</span> <span class="o">=</span> <span class="n">zlib</span><span class="o">.</span><span class="n">crc32</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span>
            <span class="n">verify</span> <span class="o">=</span> <span class="n">zlib</span><span class="o">.</span><span class="n">crc32</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">verify</span><span class="p">)</span>
            <span class="c1"># Whether the output from zlib.crc32 is signed or not varies</span>
            <span class="c1"># according to hideous implementation details, see</span>
            <span class="c1"># http://bugs.python.org/issue1202 .</span>
            <span class="c1"># We coerce it to be positive here (in a way which works on</span>
            <span class="c1"># Python 2.3 and older).</span>
            <span class="n">verify</span> <span class="o">&amp;=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">verify</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;!I&#39;</span><span class="p">,</span> <span class="n">verify</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">checksum</span> <span class="o">!=</span> <span class="n">verify</span><span class="p">:</span>
                <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">)</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;!I&#39;</span><span class="p">,</span> <span class="n">checksum</span><span class="p">)</span>
                <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">)</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;!I&#39;</span><span class="p">,</span> <span class="n">verify</span><span class="p">)</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Checksum error in </span><span class="si">%s</span><span class="s2"> chunk: 0x</span><span class="si">%08X</span><span class="s2"> != 0x</span><span class="si">%08X</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="nb">type</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">lenient</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ChunkError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">,</span> <span class="n">data</span></div>

<div class="viewcode-block" id="Reader.chunks"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Reader.chunks">[docs]</a>    <span class="k">def</span> <span class="nf">chunks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator that will yield each chunk as a</span>
<span class="sd">        (*chunktype*, *content*) pair.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">t</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk</span><span class="p">()</span>
            <span class="k">yield</span> <span class="n">t</span><span class="p">,</span> <span class="n">v</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;IEND&#39;</span><span class="p">:</span>
                <span class="k">break</span></div>

<div class="viewcode-block" id="Reader.undo_filter"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Reader.undo_filter">[docs]</a>    <span class="k">def</span> <span class="nf">undo_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_type</span><span class="p">,</span> <span class="n">scanline</span><span class="p">,</span> <span class="n">previous</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Undo the filter for a scanline.  `scanline` is a sequence of</span>
<span class="sd">        bytes that does not include the initial filter type byte.</span>
<span class="sd">        `previous` is decoded previous scanline (for straightlaced</span>
<span class="sd">        images this is the previous pixel row, but for interlaced</span>
<span class="sd">        images, it is the previous scanline in the reduced image, which</span>
<span class="sd">        in general is not the previous pixel row in the final image).</span>
<span class="sd">        When there is no previous scanline (the first row of a</span>
<span class="sd">        straightlaced image, or the first row in one of the passes in an</span>
<span class="sd">        interlaced image), then this argument should be ``None``.</span>

<span class="sd">        The scanline will have the effects of filtering removed, and the</span>
<span class="sd">        result will be returned as a fresh sequence of bytes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># :todo: Would it be better to update scanline in place?</span>
        <span class="c1"># Yes, with the Cython extension making the undo_filter fast,</span>
        <span class="c1"># updating scanline inplace makes the code 3 times faster</span>
        <span class="c1"># (reading 50 images of 800x800 went from 40s to 16s)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">scanline</span>

        <span class="k">if</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">if</span> <span class="n">filter_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span>
                <span class="s1">&#39;Invalid PNG Filter Type.&#39;</span>
                <span class="s1">&#39;  See http://www.w3.org/TR/2003/REC-PNG-20031110/#9Filters .&#39;</span><span class="p">)</span>

        <span class="c1"># Filter unit.  The stride from one pixel to the corresponding</span>
        <span class="c1"># byte from the previous pixel.  Normally this is the pixel</span>
        <span class="c1"># size in bytes, but when this is smaller than 1, the previous</span>
        <span class="c1"># byte is used instead.</span>
        <span class="n">fu</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psize</span><span class="p">)</span>

        <span class="c1"># For the first line of a pass, synthesize a dummy previous</span>
        <span class="c1"># line.  An alternative approach would be to observe that on the</span>
        <span class="c1"># first line &#39;up&#39; is the same as &#39;null&#39;, &#39;paeth&#39; is the same</span>
        <span class="c1"># as &#39;sub&#39;, with only &#39;average&#39; requiring any special case.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">previous</span><span class="p">:</span>
            <span class="n">previous</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">scanline</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">sub</span><span class="p">():</span>
            <span class="sd">&quot;&quot;&quot;Undo sub filter.&quot;&quot;&quot;</span>

            <span class="n">ai</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># Loop starts at index fu.  Observe that the initial part</span>
            <span class="c1"># of the result is already filled in correctly with</span>
            <span class="c1"># scanline.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fu</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">scanline</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">ai</span><span class="p">]</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
                <span class="n">ai</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">def</span> <span class="nf">up</span><span class="p">():</span>
            <span class="sd">&quot;&quot;&quot;Undo up filter.&quot;&quot;&quot;</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">scanline</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">previous</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>

        <span class="k">def</span> <span class="nf">average</span><span class="p">():</span>
            <span class="sd">&quot;&quot;&quot;Undo average filter.&quot;&quot;&quot;</span>

            <span class="n">ai</span> <span class="o">=</span> <span class="o">-</span><span class="n">fu</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">scanline</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ai</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">ai</span><span class="p">]</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">previous</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="p">((</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
                <span class="n">ai</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">def</span> <span class="nf">paeth</span><span class="p">():</span>
            <span class="sd">&quot;&quot;&quot;Undo Paeth filter.&quot;&quot;&quot;</span>

            <span class="c1"># Also used for ci.</span>
            <span class="n">ai</span> <span class="o">=</span> <span class="o">-</span><span class="n">fu</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">scanline</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ai</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">ai</span><span class="p">]</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">previous</span><span class="p">[</span><span class="n">ai</span><span class="p">]</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">previous</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">-</span> <span class="n">c</span>
                <span class="n">pa</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
                <span class="n">pb</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span>
                <span class="n">pc</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pa</span> <span class="o">&lt;=</span> <span class="n">pb</span> <span class="ow">and</span> <span class="n">pa</span> <span class="o">&lt;=</span> <span class="n">pc</span><span class="p">:</span>
                    <span class="n">pr</span> <span class="o">=</span> <span class="n">a</span>
                <span class="k">elif</span> <span class="n">pb</span> <span class="o">&lt;=</span> <span class="n">pc</span><span class="p">:</span>
                    <span class="n">pr</span> <span class="o">=</span> <span class="n">b</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pr</span> <span class="o">=</span> <span class="n">c</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">pr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
                <span class="n">ai</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Call appropriate filter algorithm.  Note that 0 has already</span>
        <span class="c1"># been dealt with.</span>
        <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">pngfilters</span><span class="o">.</span><span class="n">undo_filter_sub</span><span class="p">,</span> <span class="n">pngfilters</span><span class="o">.</span><span class="n">undo_filter_up</span><span class="p">,</span>
         <span class="n">pngfilters</span><span class="o">.</span><span class="n">undo_filter_average</span><span class="p">,</span>
         <span class="n">pngfilters</span><span class="o">.</span><span class="n">undo_filter_paeth</span><span class="p">)[</span><span class="n">filter_type</span><span class="p">](</span><span class="n">fu</span><span class="p">,</span> <span class="n">scanline</span><span class="p">,</span> <span class="n">previous</span><span class="p">,</span>
                                                    <span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Reader.deinterlace"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Reader.deinterlace">[docs]</a>    <span class="k">def</span> <span class="nf">deinterlace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read raw pixel data, undo filters, deinterlace, and flatten.</span>
<span class="sd">        Return in flat row flat pixel format.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Values per row (of the target image)</span>
        <span class="n">vpr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">planes</span>

        <span class="c1"># Make a result array, and make it big enough.  Interleaving</span>
        <span class="c1"># writes to the output array randomly (well, not quite), so the</span>
        <span class="c1"># entire output array must be in memory.</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;BH&#39;</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">vpr</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">)</span>
        <span class="n">source_offset</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">xstart</span><span class="p">,</span> <span class="n">ystart</span><span class="p">,</span> <span class="n">xstep</span><span class="p">,</span> <span class="n">ystep</span> <span class="ow">in</span> <span class="n">_adam7</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">xstart</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># The previous (reconstructed) scanline.  None at the</span>
            <span class="c1"># beginning of a pass to indicate that there is no previous</span>
            <span class="c1"># line.</span>
            <span class="n">recon</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># Pixels per row (reduced pass image)</span>
            <span class="n">ppr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="n">xstart</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">xstep</span><span class="p">)))</span>
            <span class="c1"># Row size in bytes for this pass.</span>
            <span class="n">row_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psize</span> <span class="o">*</span> <span class="n">ppr</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ystart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">ystep</span><span class="p">):</span>
                <span class="n">filter_type</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[</span><span class="n">source_offset</span><span class="p">]</span>
                <span class="n">source_offset</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">scanline</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[</span><span class="n">source_offset</span><span class="p">:</span><span class="n">source_offset</span> <span class="o">+</span> <span class="n">row_size</span><span class="p">]</span>
                <span class="n">source_offset</span> <span class="o">+=</span> <span class="n">row_size</span>
                <span class="n">recon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">undo_filter</span><span class="p">(</span><span class="n">filter_type</span><span class="p">,</span> <span class="n">scanline</span><span class="p">,</span> <span class="n">recon</span><span class="p">)</span>
                <span class="c1"># Convert so that there is one element per pixel value</span>
                <span class="n">flat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">serialtoflat</span><span class="p">(</span><span class="n">recon</span><span class="p">,</span> <span class="n">ppr</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">xstep</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">xstart</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">vpr</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">offset</span><span class="p">:</span><span class="n">offset</span> <span class="o">+</span> <span class="n">vpr</span><span class="p">]</span> <span class="o">=</span> <span class="n">flat</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">vpr</span> <span class="o">+</span> <span class="n">xstart</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">planes</span>
                    <span class="n">end_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">vpr</span>
                    <span class="n">skip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">planes</span> <span class="o">*</span> <span class="n">xstep</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">planes</span><span class="p">):</span>
                        <span class="n">a</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">i</span><span class="p">:</span><span class="n">end_offset</span><span class="p">:</span><span class="n">skip</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="n">flat</span><span class="p">[</span><span class="n">i</span><span class="p">::</span><span class="bp">self</span><span class="o">.</span><span class="n">planes</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">a</span></div>

<div class="viewcode-block" id="Reader.iterboxed"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Reader.iterboxed">[docs]</a>    <span class="k">def</span> <span class="nf">iterboxed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterator that yields each scanline in boxed row flat pixel</span>
<span class="sd">        format.  `rows` should be an iterator that yields the bytes of</span>
<span class="sd">        each row in turn.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">asvalues</span><span class="p">(</span><span class="n">raw</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Convert a row of raw bytes into a flat row.  Result will</span>
<span class="sd">            be a freshly allocated object, not shared with</span>
<span class="sd">            argument.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">raw</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span> <span class="o">==</span> <span class="mi">16</span><span class="p">:</span>
                <span class="n">raw</span> <span class="o">=</span> <span class="n">tostring</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;!</span><span class="si">%d</span><span class="s1">H&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">raw</span><span class="p">))</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span> <span class="o">&lt;</span> <span class="mi">8</span>
            <span class="n">width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span>
            <span class="c1"># Samples per byte</span>
            <span class="n">spb</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">shifts</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">spb</span><span class="p">)))]</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">raw</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">o</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">shifts</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">out</span><span class="p">[:</span><span class="n">width</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">asvalues</span><span class="p">,</span> <span class="n">rows</span><span class="p">)</span></div>

<div class="viewcode-block" id="Reader.serialtoflat"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Reader.serialtoflat">[docs]</a>    <span class="k">def</span> <span class="nf">serialtoflat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert serial format (byte stream) pixel data to flat row</span>
<span class="sd">        flat pixel.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">bytes</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span> <span class="o">==</span> <span class="mi">16</span><span class="p">:</span>
            <span class="nb">bytes</span> <span class="o">=</span> <span class="n">tostring</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;!</span><span class="si">%d</span><span class="s1">H&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">bytes</span><span class="p">))</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span> <span class="o">&lt;</span> <span class="mi">8</span>
        <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span>
        <span class="c1"># Samples per byte</span>
        <span class="n">spb</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">,</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">spb</span><span class="p">)))))</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">width</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">bytes</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">([(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">o</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">))</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shifts</span><span class="p">][:</span><span class="n">l</span><span class="p">])</span>
            <span class="n">l</span> <span class="o">-=</span> <span class="n">spb</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">width</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="Reader.iterstraight"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Reader.iterstraight">[docs]</a>    <span class="k">def</span> <span class="nf">iterstraight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterator that undoes the effect of filtering, and yields</span>
<span class="sd">        each row in serialised format (as a sequence of bytes).</span>
<span class="sd">        Assumes input is straightlaced.  `raw` should be an iterable</span>
<span class="sd">        that yields the raw bytes in chunks of arbitrary size.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># length of row, in bytes</span>
        <span class="n">rb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_bytes</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
        <span class="c1"># The previous (reconstructed) scanline.  None indicates first</span>
        <span class="c1"># line of image.</span>
        <span class="n">recon</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">some</span> <span class="ow">in</span> <span class="n">raw</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">some</span><span class="p">)</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">rb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">filter_type</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">scanline</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">rb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">a</span><span class="p">[:</span><span class="n">rb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">recon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">undo_filter</span><span class="p">(</span><span class="n">filter_type</span><span class="p">,</span> <span class="n">scanline</span><span class="p">,</span> <span class="n">recon</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">recon</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># :file:format We get here with a file format error:</span>
            <span class="c1"># when the available bytes (after decompressing) do not</span>
            <span class="c1"># pack into exact rows.</span>
            <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span><span class="s1">&#39;Wrong size for decompressed IDAT chunk.&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="Reader.validate_signature"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Reader.validate_signature">[docs]</a>    <span class="k">def</span> <span class="nf">validate_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If signature (header) has not been read then read and</span>
<span class="sd">        validate it; otherwise do nothing.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">signature</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">signature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">signature</span> <span class="o">!=</span> <span class="n">_signature</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span><span class="s2">&quot;PNG file has invalid signature.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Reader.preamble"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Reader.preamble">[docs]</a>    <span class="k">def</span> <span class="nf">preamble</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lenient</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract the image metadata by reading the initial part of</span>
<span class="sd">        the PNG file up to the start of the ``IDAT`` chunk.  All the</span>
<span class="sd">        chunks that precede the ``IDAT`` chunk are read and either</span>
<span class="sd">        processed for metadata or discarded.</span>

<span class="sd">        If the optional `lenient` argument evaluates to `True`, checksum</span>
<span class="sd">        failures will raise warnings rather than exceptions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">validate_signature</span><span class="p">()</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">atchunk</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">atchunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunklentype</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atchunk</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span><span class="s1">&#39;This PNG file has no IDAT chunks.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atchunk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;IDAT&#39;</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_chunk</span><span class="p">(</span><span class="n">lenient</span><span class="o">=</span><span class="n">lenient</span><span class="p">)</span></div>

<div class="viewcode-block" id="Reader.chunklentype"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Reader.chunklentype">[docs]</a>    <span class="k">def</span> <span class="nf">chunklentype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reads just enough of the input to determine the next</span>
<span class="sd">        chunk&#39;s length and type, returned as a (*length*, *type*) pair</span>
<span class="sd">        where *type* is a string.  If there are no more chunks, ``None``</span>
<span class="sd">        is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span>
                <span class="s1">&#39;End of file whilst reading chunk length and type.&#39;</span><span class="p">)</span>
        <span class="n">length</span><span class="p">,</span> <span class="nb">type</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;!I4s&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">**</span><span class="mi">31</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span><span class="s1">&#39;Chunk </span><span class="si">%s</span><span class="s1"> is too large: </span><span class="si">%d</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">length</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">length</span><span class="p">,</span> <span class="nb">type</span></div>

<div class="viewcode-block" id="Reader.process_chunk"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Reader.process_chunk">[docs]</a>    <span class="k">def</span> <span class="nf">process_chunk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lenient</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Process the next chunk and its data.  This only processes the</span>
<span class="sd">        following chunk types, all others are ignored: ``IHDR``,</span>
<span class="sd">        ``PLTE``, ``bKGD``, ``tRNS``, ``gAMA``, ``sBIT``, ``pHYs``.</span>

<span class="sd">        If the optional `lenient` argument evaluates to `True`,</span>
<span class="sd">        checksum failures will raise warnings rather than exceptions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">type</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="n">lenient</span><span class="o">=</span><span class="n">lenient</span><span class="p">)</span>
        <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;_process_&#39;</span> <span class="o">+</span> <span class="n">as_str</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
            <span class="n">m</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_process_IHDR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="c1"># http://www.w3.org/TR/PNG/#11IHDR</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">13</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span><span class="s1">&#39;IHDR chunk has incorrect length.&#39;</span><span class="p">)</span>
        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">color_type</span><span class="p">,</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">compression</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">,</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">interlace</span><span class="p">)</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;!2I5B&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

        <span class="n">check_bitdepth_colortype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">color_type</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compression</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Error</span><span class="p">(</span><span class="s2">&quot;unknown compression method </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">compression</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span>
                <span class="s2">&quot;Unknown filter method </span><span class="si">%d</span><span class="s2">,&quot;</span>
                <span class="s2">&quot; see http://www.w3.org/TR/2003/REC-PNG-20031110/#9Filters .&quot;</span> <span class="o">%</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interlace</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span>
                <span class="s2">&quot;Unknown interlace method </span><span class="si">%d</span><span class="s2">,&quot;</span>
                <span class="s2">&quot; see http://www.w3.org/TR/2003/REC-PNG-20031110/#8InterlaceMethods .&quot;</span>
                <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">interlace</span><span class="p">)</span>

        <span class="c1"># Derived values</span>
        <span class="c1"># http://www.w3.org/TR/PNG/#6Colour-values</span>
        <span class="n">colormap</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">color_type</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">greyscale</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">color_type</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">color_type</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">color_planes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="n">greyscale</span> <span class="ow">or</span> <span class="n">colormap</span><span class="p">]</span>
        <span class="n">planes</span> <span class="o">=</span> <span class="n">color_planes</span> <span class="o">+</span> <span class="n">alpha</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">colormap</span> <span class="o">=</span> <span class="n">colormap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">greyscale</span> <span class="o">=</span> <span class="n">greyscale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color_planes</span> <span class="o">=</span> <span class="n">color_planes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">planes</span> <span class="o">=</span> <span class="n">planes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psize</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="n">planes</span>
        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psize</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">psize</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">psize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psize</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">row_bytes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">psize</span><span class="p">))</span>
        <span class="c1"># Stores PLTE chunk if present, and is used to check</span>
        <span class="c1"># chunk ordering constraints.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plte</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Stores tRNS chunk if present, and is used to check chunk</span>
        <span class="c1"># ordering constraints.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trns</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Stores sbit chunk if present.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sbit</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_process_PLTE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="c1"># http://www.w3.org/TR/PNG/#11PLTE</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plte</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Multiple PLTE chunks present.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plte</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span><span class="s2">&quot;PLTE chunk&#39;s length should be a multiple of 3.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span><span class="s2">&quot;PLTE chunk is too long.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span><span class="s2">&quot;Empty PLTE is not allowed.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_process_bKGD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">colormap</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">plte</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;PLTE chunk is required before bKGD chunk.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">background</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">background</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;!</span><span class="si">%d</span><span class="s2">H&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">color_planes</span><span class="p">,</span>
                                                <span class="n">data</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">struct</span><span class="o">.</span><span class="n">error</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span><span class="s2">&quot;bKGD chunk has incorrect length.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_process_tRNS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="c1"># http://www.w3.org/TR/PNG/#11tRNS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trns</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">colormap</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">plte</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;PLTE chunk is required before tRNS chunk.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plte</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="c1"># Was warning, but promoted to Error as it</span>
                    <span class="c1"># would otherwise cause pain later on.</span>
                    <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span><span class="s2">&quot;tRNS chunk is too long.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span>
                    <span class="s2">&quot;tRNS chunk is not valid with colour type </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">color_type</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transparent</span> <span class="o">=</span> \
                    <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;!</span><span class="si">%d</span><span class="s2">H&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">color_planes</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">struct</span><span class="o">.</span><span class="n">error</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span><span class="s2">&quot;tRNS chunk has incorrect length.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_process_gAMA</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;!L&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mf">100000.0</span>
        <span class="k">except</span> <span class="n">struct</span><span class="o">.</span><span class="n">error</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span><span class="s2">&quot;gAMA chunk has incorrect length.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_process_sBIT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sbit</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colormap</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span>
                <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">colormap</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">planes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span><span class="s2">&quot;sBIT chunk has incorrect length.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_process_pHYs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="c1"># http://www.w3.org/TR/PNG/#11pHYs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phys</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;!LLB&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="n">struct</span><span class="o">.</span><span class="n">calcsize</span><span class="p">(</span><span class="n">fmt</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span><span class="s2">&quot;pHYs chunk has incorrect length.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_pixels_per_unit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_pixels_per_unit</span><span class="p">,</span> <span class="n">unit</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span>
            <span class="n">fmt</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit_is_meter</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>

<div class="viewcode-block" id="Reader.read"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Reader.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lenient</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read the PNG file and decode it.  Returns (`width`, `height`,</span>
<span class="sd">        `pixels`, `metadata`).</span>

<span class="sd">        May use excessive memory.</span>

<span class="sd">        `pixels` are returned in boxed row flat pixel format.</span>

<span class="sd">        If the optional `lenient` argument evaluates to True,</span>
<span class="sd">        checksum failures will raise warnings rather than exceptions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">iteridat</span><span class="p">():</span>
            <span class="sd">&quot;&quot;&quot;Iterator that yields all the ``IDAT`` chunks as strings.&quot;&quot;&quot;</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="nb">type</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="n">lenient</span><span class="o">=</span><span class="n">lenient</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ChunkError</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;IEND&#39;</span><span class="p">:</span>
                    <span class="c1"># http://www.w3.org/TR/PNG/#11IEND</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="nb">type</span> <span class="o">!=</span> <span class="sa">b</span><span class="s1">&#39;IDAT&#39;</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># type == b&#39;IDAT&#39;</span>
                <span class="c1"># http://www.w3.org/TR/PNG/#11IDAT</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">colormap</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">plte</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;PLTE chunk is required before IDAT chunk&quot;</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">data</span>

        <span class="k">def</span> <span class="nf">iterdecomp</span><span class="p">(</span><span class="n">idat</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Iterator that yields decompressed strings.  `idat` should</span>
<span class="sd">            be an iterator that yields the ``IDAT`` chunk data.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># Currently, with no max_length parameter to decompress,</span>
            <span class="c1"># this routine will do one yield per IDAT chunk: Not very</span>
            <span class="c1"># incremental.</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">zlib</span><span class="o">.</span><span class="n">decompressobj</span><span class="p">()</span>
            <span class="c1"># Each IDAT chunk is passed to the decompressor, then any</span>
            <span class="c1"># remaining state is decompressed out.</span>
            <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">idat</span><span class="p">:</span>
                <span class="c1"># :todo: add a max_length argument here to limit output</span>
                <span class="c1"># size.</span>
                <span class="k">yield</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">decompress</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
            <span class="k">yield</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">flush</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">preamble</span><span class="p">(</span><span class="n">lenient</span><span class="o">=</span><span class="n">lenient</span><span class="p">)</span>
        <span class="n">raw</span> <span class="o">=</span> <span class="n">iterdecomp</span><span class="p">(</span><span class="n">iteridat</span><span class="p">())</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interlace</span><span class="p">:</span>
            <span class="n">raw</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">raw</span><span class="p">))</span>
            <span class="n">arraycode</span> <span class="o">=</span> <span class="s1">&#39;BH&#39;</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">]</span>
            <span class="c1"># Like :meth:`group` but producing an array.array object for</span>
            <span class="c1"># each row.</span>
            <span class="n">pixels</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="o">*</span><span class="n">row</span><span class="p">:</span> <span class="n">array</span><span class="p">(</span><span class="n">arraycode</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span>
                <span class="o">*</span><span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deinterlace</span><span class="p">(</span><span class="n">raw</span><span class="p">))]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">planes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pixels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterboxed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iterstraight</span><span class="p">(</span><span class="n">raw</span><span class="p">))</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="s1">&#39;greyscale alpha planes bitdepth interlace&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">():</span>
            <span class="n">meta</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="s1">&#39;gamma transparent background&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">():</span>
            <span class="n">a</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">meta</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plte</span><span class="p">:</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;palette&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">palette</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">pixels</span><span class="p">,</span> <span class="n">meta</span></div>

<div class="viewcode-block" id="Reader.read_flat"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Reader.read_flat">[docs]</a>    <span class="k">def</span> <span class="nf">read_flat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read a PNG file and decode it into flat row flat pixel format.</span>
<span class="sd">        Returns (*width*, *height*, *pixels*, *metadata*).</span>

<span class="sd">        May use excessive memory.</span>

<span class="sd">        `pixels` are returned in flat row flat pixel format.</span>

<span class="sd">        See also the :meth:`read` method which returns pixels in the</span>
<span class="sd">        more stream-friendly boxed row flat pixel format.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">pixel</span><span class="p">,</span> <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="n">arraycode</span> <span class="o">=</span> <span class="s1">&#39;BH&#39;</span> <span class="p">[</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;bitdepth&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">]</span>
        <span class="n">pixel</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">arraycode</span><span class="p">,</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">pixel</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">pixel</span><span class="p">,</span> <span class="n">meta</span></div>

<div class="viewcode-block" id="Reader.palette"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Reader.palette">[docs]</a>    <span class="k">def</span> <span class="nf">palette</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="s1">&#39;natural&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a palette that is a sequence of 3-tuples or 4-tuples,</span>
<span class="sd">        synthesizing it from the ``PLTE`` and ``tRNS`` chunks.  These</span>
<span class="sd">        chunks should have already been processed (for example, by</span>
<span class="sd">        calling the :meth:`preamble` method).  All the tuples are the</span>
<span class="sd">        same size: 3-tuples if there is no ``tRNS`` chunk, 4-tuples when</span>
<span class="sd">        there is a ``tRNS`` chunk.  Assumes that the image is colour type</span>
<span class="sd">        3 and therefore a ``PLTE`` chunk is required.</span>

<span class="sd">        If the `alpha` argument is ``&#39;force&#39;`` then an alpha channel is</span>
<span class="sd">        always added, forcing the result to be a sequence of 4-tuples.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">plte</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span>
                <span class="s2">&quot;Required PLTE chunk is missing in colour type 3 image.&quot;</span><span class="p">)</span>
        <span class="n">plte</span> <span class="o">=</span> <span class="n">group</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">plte</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trns</span> <span class="ow">or</span> <span class="n">alpha</span> <span class="o">==</span> <span class="s1">&#39;force&#39;</span><span class="p">:</span>
            <span class="n">trns</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">trns</span> <span class="ow">or</span> <span class="p">[])</span>
            <span class="n">trns</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mi">255</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">plte</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">trns</span><span class="p">)))</span>
            <span class="n">plte</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">plte</span><span class="p">,</span> <span class="n">group</span><span class="p">(</span><span class="n">trns</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">plte</span></div>

<div class="viewcode-block" id="Reader.asDirect"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Reader.asDirect">[docs]</a>    <span class="k">def</span> <span class="nf">asDirect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the image data as a direct representation of an</span>
<span class="sd">        ``x * y * planes`` array.  This method is intended to remove the</span>
<span class="sd">        need for callers to deal with palettes and transparency</span>
<span class="sd">        themselves.  Images with a palette (colour type 3)</span>
<span class="sd">        are converted to RGB or RGBA; images with transparency (a</span>
<span class="sd">        ``tRNS`` chunk) are converted to LA or RGBA as appropriate.</span>
<span class="sd">        When returned in this format the pixel values represent the</span>
<span class="sd">        colour value directly without needing to refer to palettes or</span>
<span class="sd">        transparency information.</span>

<span class="sd">        Like the :meth:`read` method this method returns a 4-tuple:</span>

<span class="sd">        (*width*, *height*, *pixels*, *meta*)</span>

<span class="sd">        This method normally returns pixel values with the bit depth</span>
<span class="sd">        they have in the source image, but when the source PNG has an</span>
<span class="sd">        ``sBIT`` chunk it is inspected and can reduce the bit depth of</span>
<span class="sd">        the result pixels; pixel values will be reduced according to</span>
<span class="sd">        the bit depth specified in the ``sBIT`` chunk (PNG nerds should</span>
<span class="sd">        note a single result bit depth is used for all channels; the</span>
<span class="sd">        maximum of the ones specified in the ``sBIT`` chunk.  An RGB565</span>
<span class="sd">        image will be rescaled to 6-bit RGB666).</span>

<span class="sd">        The *meta* dictionary that is returned reflects the `direct`</span>
<span class="sd">        format and not the original source image.  For example, an RGB</span>
<span class="sd">        source image with a ``tRNS`` chunk to represent a transparent</span>
<span class="sd">        colour, will have ``planes=3`` and ``alpha=False`` for the</span>
<span class="sd">        source image, but the *meta* dictionary returned by this method</span>
<span class="sd">        will have ``planes=4`` and ``alpha=True`` because an alpha</span>
<span class="sd">        channel is synthesized and added.</span>

<span class="sd">        *pixels* is the pixel data in boxed row flat pixel format (just</span>
<span class="sd">        like the :meth:`read` method).</span>

<span class="sd">        All the other aspects of the image data are not changed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">preamble</span><span class="p">()</span>

        <span class="c1"># Simple case, no conversion necessary.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">colormap</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">trns</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sbit</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">pixels</span><span class="p">,</span> <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">colormap</span><span class="p">:</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;colormap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trns</span><span class="p">)</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;bitdepth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;planes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">+</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trns</span><span class="p">)</span>
            <span class="n">plte</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">palette</span><span class="p">()</span>

            <span class="k">def</span> <span class="nf">iterpal</span><span class="p">(</span><span class="n">pixels</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">pixels</span><span class="p">:</span>
                    <span class="n">row</span> <span class="o">=</span> <span class="p">[</span><span class="n">plte</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">row</span><span class="p">]</span>
                    <span class="k">yield</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">row</span><span class="p">))</span>

            <span class="n">pixels</span> <span class="o">=</span> <span class="n">iterpal</span><span class="p">(</span><span class="n">pixels</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">trns</span><span class="p">:</span>
            <span class="c1"># It would be nice if there was some reasonable way</span>
            <span class="c1"># of doing this without generating a whole load of</span>
            <span class="c1"># intermediate tuples.  But tuples does seem like the</span>
            <span class="c1"># easiest way, with no other way clearly much simpler or</span>
            <span class="c1"># much faster.  (Actually, the L to LA conversion could</span>
            <span class="c1"># perhaps go faster (all those 1-tuples!), but I still</span>
            <span class="c1"># wonder whether the code proliferation is worth it)</span>
            <span class="n">it</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transparent</span>
            <span class="n">maxval</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;bitdepth&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">planes</span> <span class="o">=</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;planes&#39;</span><span class="p">]</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;planes&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">typecode</span> <span class="o">=</span> <span class="s1">&#39;BH&#39;</span> <span class="p">[</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;bitdepth&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">]</span>

            <span class="k">def</span> <span class="nf">itertrns</span><span class="p">(</span><span class="n">pixels</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">pixels</span><span class="p">:</span>
                    <span class="c1"># For each row we group it into pixels, then form a</span>
                    <span class="c1"># characterisation vector that says whether each</span>
                    <span class="c1"># pixel is opaque or not.  Then we convert</span>
                    <span class="c1"># True/False to 0/maxval (by multiplication),</span>
                    <span class="c1"># and add it as the extra channel.</span>
                    <span class="n">row</span> <span class="o">=</span> <span class="n">group</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">planes</span><span class="p">)</span>
                    <span class="n">opa</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="fm">__ne__</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
                    <span class="n">opa</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">maxval</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">,</span> <span class="n">opa</span><span class="p">)</span>
                    <span class="n">opa</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">opa</span><span class="p">))</span>  <span class="c1"># convert to 1-tuples</span>
                    <span class="k">yield</span> <span class="n">array</span><span class="p">(</span><span class="n">typecode</span><span class="p">,</span>
                                <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">opa</span><span class="p">)))</span>

            <span class="n">pixels</span> <span class="o">=</span> <span class="n">itertrns</span><span class="p">(</span><span class="n">pixels</span><span class="p">)</span>
        <span class="n">targetbitdepth</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sbit</span><span class="p">:</span>
            <span class="n">sbit</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">B&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sbit</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">sbit</span><span class="p">)</span>
            <span class="n">targetbitdepth</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sbit</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">targetbitdepth</span> <span class="o">&gt;</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;bitdepth&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">Error</span><span class="p">(</span><span class="s1">&#39;sBIT chunk </span><span class="si">%r</span><span class="s1"> exceeds bitdepth </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span>
                            <span class="p">(</span><span class="n">sbit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitdepth</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">sbit</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">Error</span><span class="p">(</span><span class="s1">&#39;sBIT chunk </span><span class="si">%r</span><span class="s1"> has a 0-entry&#39;</span> <span class="o">%</span> <span class="n">sbit</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">targetbitdepth</span> <span class="o">==</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;bitdepth&#39;</span><span class="p">]:</span>
                <span class="n">targetbitdepth</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">targetbitdepth</span><span class="p">:</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;bitdepth&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">targetbitdepth</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;bitdepth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">targetbitdepth</span>

            <span class="k">def</span> <span class="nf">itershift</span><span class="p">(</span><span class="n">pixels</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">pixels</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="p">[</span><span class="n">p</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">row</span><span class="p">]</span>

            <span class="n">pixels</span> <span class="o">=</span> <span class="n">itershift</span><span class="p">(</span><span class="n">pixels</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">pixels</span><span class="p">,</span> <span class="n">meta</span></div>

<div class="viewcode-block" id="Reader.asFloat"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Reader.asFloat">[docs]</a>    <span class="k">def</span> <span class="nf">asFloat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxval</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return image pixels as per :meth:`asDirect` method, but scale</span>
<span class="sd">        all pixel values to be floating point values between 0.0 and</span>
<span class="sd">        *maxval*.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">pixels</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asDirect</span><span class="p">()</span>
        <span class="n">sourcemaxval</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bitdepth&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">del</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;bitdepth&#39;</span><span class="p">]</span>
        <span class="n">info</span><span class="p">[</span><span class="s1">&#39;maxval&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">maxval</span><span class="p">)</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">maxval</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">sourcemaxval</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">iterfloat</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">pixels</span><span class="p">:</span>
                <span class="k">yield</span> <span class="p">[</span><span class="n">factor</span> <span class="o">*</span> <span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">row</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">iterfloat</span><span class="p">(),</span> <span class="n">info</span></div>

    <span class="k">def</span> <span class="nf">_as_rescale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">get</span><span class="p">,</span> <span class="n">targetbitdepth</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper used by :meth:`asRGB8` and :meth:`asRGBA8`.&quot;&quot;&quot;</span>

        <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">pixels</span><span class="p">,</span> <span class="n">meta</span> <span class="o">=</span> <span class="n">get</span><span class="p">()</span>
        <span class="n">maxval</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;bitdepth&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">targetmaxval</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">targetbitdepth</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">targetmaxval</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">maxval</span><span class="p">)</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;bitdepth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">targetbitdepth</span>

        <span class="k">def</span> <span class="nf">iterscale</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">pixels</span><span class="p">:</span>
                <span class="k">yield</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">factor</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">row</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">maxval</span> <span class="o">==</span> <span class="n">targetmaxval</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">pixels</span><span class="p">,</span> <span class="n">meta</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">iterscale</span><span class="p">(),</span> <span class="n">meta</span>

<div class="viewcode-block" id="Reader.asRGB8"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Reader.asRGB8">[docs]</a>    <span class="k">def</span> <span class="nf">asRGB8</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the image data as an RGB pixels with 8-bits per</span>
<span class="sd">        sample.  This is like the :meth:`asRGB` method except that</span>
<span class="sd">        this method additionally rescales the values so that they</span>
<span class="sd">        are all between 0 and 255 (8-bit).  In the case where the</span>
<span class="sd">        source image has a bit depth &lt; 8 the transformation preserves</span>
<span class="sd">        all the information; where the source image has bit depth</span>
<span class="sd">        &gt; 8, then rescaling to 8-bit values loses precision.  No</span>
<span class="sd">        dithering is performed.  Like :meth:`asRGB`, an alpha channel</span>
<span class="sd">        in the source image will raise an exception.</span>

<span class="sd">        This function returns a 4-tuple:</span>
<span class="sd">        (*width*, *height*, *pixels*, *metadata*).</span>
<span class="sd">        *width*, *height*, *metadata* are as per the</span>
<span class="sd">        :meth:`read` method.</span>

<span class="sd">        *pixels* is the pixel data in boxed row flat pixel format.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_as_rescale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asRGB</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span></div>

<div class="viewcode-block" id="Reader.asRGBA8"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Reader.asRGBA8">[docs]</a>    <span class="k">def</span> <span class="nf">asRGBA8</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the image data as RGBA pixels with 8-bits per</span>
<span class="sd">        sample.  This method is similar to :meth:`asRGB8` and</span>
<span class="sd">        :meth:`asRGBA`:  The result pixels have an alpha channel, *and*</span>
<span class="sd">        values are rescaled to the range 0 to 255.  The alpha channel is</span>
<span class="sd">        synthesized if necessary (with a small speed penalty).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_as_rescale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asRGBA</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span></div>

<div class="viewcode-block" id="Reader.asRGB"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Reader.asRGB">[docs]</a>    <span class="k">def</span> <span class="nf">asRGB</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return image as RGB pixels.  RGB colour images are passed</span>
<span class="sd">        through unchanged; greyscales are expanded into RGB</span>
<span class="sd">        triplets (there is a small speed overhead for doing this).</span>

<span class="sd">        An alpha channel in the source image will raise an</span>
<span class="sd">        exception.</span>

<span class="sd">        The return values are as for the :meth:`read` method</span>
<span class="sd">        except that the *metadata* reflect the returned pixels, not the</span>
<span class="sd">        source image.  In particular, for this method</span>
<span class="sd">        ``metadata[&#39;greyscale&#39;]`` will be ``False``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">pixels</span><span class="p">,</span> <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asDirect</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">Error</span><span class="p">(</span><span class="s2">&quot;will not convert image with alpha channel to RGB&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;greyscale&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">pixels</span><span class="p">,</span> <span class="n">meta</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;greyscale&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">typecode</span> <span class="o">=</span> <span class="s1">&#39;BH&#39;</span> <span class="p">[</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;bitdepth&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">iterrgb</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">pixels</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">typecode</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">width</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span>
                <span class="k">yield</span> <span class="n">a</span>

        <span class="k">return</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">iterrgb</span><span class="p">(),</span> <span class="n">meta</span></div>

<div class="viewcode-block" id="Reader.asRGBA"><a class="viewcode-back" href="../../../DF-VO/libs.flowlib.png.html#libs.flowlib.png.Reader.asRGBA">[docs]</a>    <span class="k">def</span> <span class="nf">asRGBA</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return image as RGBA pixels.  Greyscales are expanded into</span>
<span class="sd">        RGB triplets; an alpha channel is synthesized if necessary.</span>
<span class="sd">        The return values are as for the :meth:`read` method</span>
<span class="sd">        except that the *metadata* reflect the returned pixels, not the</span>
<span class="sd">        source image.  In particular, for this method</span>
<span class="sd">        ``metadata[&#39;greyscale&#39;]`` will be ``False``, and</span>
<span class="sd">        ``metadata[&#39;alpha&#39;]`` will be ``True``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">pixels</span><span class="p">,</span> <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asDirect</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;greyscale&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">pixels</span><span class="p">,</span> <span class="n">meta</span>
        <span class="n">typecode</span> <span class="o">=</span> <span class="s1">&#39;BH&#39;</span> <span class="p">[</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;bitdepth&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">]</span>
        <span class="n">maxval</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;bitdepth&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">maxbuffer</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;=&#39;</span> <span class="o">+</span> <span class="n">typecode</span><span class="p">,</span> <span class="n">maxval</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">width</span>

        <span class="k">def</span> <span class="nf">newarray</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">typecode</span><span class="p">,</span> <span class="n">maxbuffer</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;greyscale&#39;</span><span class="p">]:</span>
            <span class="c1"># LA to RGBA</span>
            <span class="k">def</span> <span class="nf">convert</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">pixels</span><span class="p">:</span>
                    <span class="c1"># Create a fresh target row, then copy L channel</span>
                    <span class="c1"># into first three target channels, and A channel</span>
                    <span class="c1"># into fourth channel.</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">newarray</span><span class="p">()</span>
                    <span class="n">pngfilters</span><span class="o">.</span><span class="n">convert_la_to_rgba</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="n">a</span>
        <span class="k">elif</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;greyscale&#39;</span><span class="p">]:</span>
            <span class="c1"># L to RGBA</span>
            <span class="k">def</span> <span class="nf">convert</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">pixels</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">newarray</span><span class="p">()</span>
                    <span class="n">pngfilters</span><span class="o">.</span><span class="n">convert_l_to_rgba</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="n">a</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;greyscale&#39;</span><span class="p">]</span>

            <span class="c1"># RGB to RGBA</span>
            <span class="k">def</span> <span class="nf">convert</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">pixels</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">newarray</span><span class="p">()</span>
                    <span class="n">pngfilters</span><span class="o">.</span><span class="n">convert_rgb_to_rgba</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="n">a</span>

        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;greyscale&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">convert</span><span class="p">(),</span> <span class="n">meta</span></div></div>


<span class="k">def</span> <span class="nf">check_bitdepth_colortype</span><span class="p">(</span><span class="n">bitdepth</span><span class="p">,</span> <span class="n">colortype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check that `bitdepth` and `colortype` are both valid,</span>
<span class="sd">    and specified in a valid combination. Returns if valid,</span>
<span class="sd">    raise an Exception if not valid.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">bitdepth</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span><span class="s2">&quot;invalid bit depth </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">bitdepth</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">colortype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span><span class="s2">&quot;invalid colour type </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">colortype</span><span class="p">)</span>
    <span class="c1"># Check indexed (palettized) images have 8 or fewer bits</span>
    <span class="c1"># per pixel; check only indexed or greyscale images have</span>
    <span class="c1"># fewer than 8 bits per pixel.</span>
    <span class="k">if</span> <span class="n">colortype</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">bitdepth</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span>
            <span class="s2">&quot;Indexed images (colour type </span><span class="si">%d</span><span class="s2">) cannot&quot;</span>
            <span class="s2">&quot; have bitdepth &gt; 8 (bit depth </span><span class="si">%d</span><span class="s2">).&quot;</span>
            <span class="s2">&quot; See http://www.w3.org/TR/2003/REC-PNG-20031110/#table111 .&quot;</span> <span class="o">%</span>
            <span class="p">(</span><span class="n">bitdepth</span><span class="p">,</span> <span class="n">colortype</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">bitdepth</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="ow">and</span> <span class="n">colortype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span>
            <span class="s2">&quot;Illegal combination of bit depth (</span><span class="si">%d</span><span class="s2">)&quot;</span>
            <span class="s2">&quot; and colour type (</span><span class="si">%d</span><span class="s2">).&quot;</span>
            <span class="s2">&quot; See http://www.w3.org/TR/2003/REC-PNG-20031110/#table111 .&quot;</span> <span class="o">%</span>
            <span class="p">(</span><span class="n">bitdepth</span><span class="p">,</span> <span class="n">colortype</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">isinteger</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">x</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="c1"># === Support for users without Cython ===</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">pngfilters</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>

    <span class="k">class</span> <span class="nc">pngfilters</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">undo_filter_sub</span><span class="p">(</span><span class="n">filter_unit</span><span class="p">,</span> <span class="n">scanline</span><span class="p">,</span> <span class="n">previous</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Undo sub filter.&quot;&quot;&quot;</span>

            <span class="n">ai</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># Loops starts at index fu.  Observe that the initial part</span>
            <span class="c1"># of the result is already filled in correctly with</span>
            <span class="c1"># scanline.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">filter_unit</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">scanline</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">ai</span><span class="p">]</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
                <span class="n">ai</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">undo_filter_sub</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">undo_filter_sub</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">undo_filter_up</span><span class="p">(</span><span class="n">filter_unit</span><span class="p">,</span> <span class="n">scanline</span><span class="p">,</span> <span class="n">previous</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Undo up filter.&quot;&quot;&quot;</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">scanline</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">previous</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>

        <span class="n">undo_filter_up</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">undo_filter_up</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">undo_filter_average</span><span class="p">(</span><span class="n">filter_unit</span><span class="p">,</span> <span class="n">scanline</span><span class="p">,</span> <span class="n">previous</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Undo up filter.&quot;&quot;&quot;</span>

            <span class="n">ai</span> <span class="o">=</span> <span class="o">-</span><span class="n">filter_unit</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">scanline</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ai</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">ai</span><span class="p">]</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">previous</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="p">((</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
                <span class="n">ai</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">undo_filter_average</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">undo_filter_average</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">undo_filter_paeth</span><span class="p">(</span><span class="n">filter_unit</span><span class="p">,</span> <span class="n">scanline</span><span class="p">,</span> <span class="n">previous</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Undo Paeth filter.&quot;&quot;&quot;</span>

            <span class="c1"># Also used for ci.</span>
            <span class="n">ai</span> <span class="o">=</span> <span class="o">-</span><span class="n">filter_unit</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">scanline</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ai</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">ai</span><span class="p">]</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">previous</span><span class="p">[</span><span class="n">ai</span><span class="p">]</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">previous</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">-</span> <span class="n">c</span>
                <span class="n">pa</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
                <span class="n">pb</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span>
                <span class="n">pc</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pa</span> <span class="o">&lt;=</span> <span class="n">pb</span> <span class="ow">and</span> <span class="n">pa</span> <span class="o">&lt;=</span> <span class="n">pc</span><span class="p">:</span>
                    <span class="n">pr</span> <span class="o">=</span> <span class="n">a</span>
                <span class="k">elif</span> <span class="n">pb</span> <span class="o">&lt;=</span> <span class="n">pc</span><span class="p">:</span>
                    <span class="n">pr</span> <span class="o">=</span> <span class="n">b</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pr</span> <span class="o">=</span> <span class="n">c</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">pr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
                <span class="n">ai</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">undo_filter_paeth</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">undo_filter_paeth</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">convert_la_to_rgba</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">::</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">result</span><span class="p">[</span><span class="mi">3</span><span class="p">::</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">convert_la_to_rgba</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">convert_la_to_rgba</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">convert_l_to_rgba</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Convert a grayscale image to RGBA. This method assumes</span>
<span class="sd">            the alpha channel in result is already correctly</span>
<span class="sd">            initialized.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">::</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span>

        <span class="n">convert_l_to_rgba</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">convert_l_to_rgba</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">convert_rgb_to_rgba</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Convert an RGB image to RGBA. This method assumes the</span>
<span class="sd">            alpha channel in result is already correctly initialized.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">::</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span>

        <span class="n">convert_rgb_to_rgba</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">convert_rgb_to_rgba</span><span class="p">)</span>


<span class="c1"># === Command Line Support ===</span>


<span class="k">def</span> <span class="nf">read_pam_header</span><span class="p">(</span><span class="n">infile</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read (the rest of a) PAM header.  `infile` should be positioned</span>
<span class="sd">    immediately after the initial &#39;P7&#39; line (at the beginning of the</span>
<span class="sd">    second line).  Returns are as for `read_pnm_header`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Unlike PBM, PGM, and PPM, we can read the header a line at a time.</span>
    <span class="n">header</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">infile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;ENDHDR&#39;</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">l</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">EOFError</span><span class="p">(</span><span class="s1">&#39;PAM ended prematurely&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;#&#39;</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">header</span><span class="p">:</span>
            <span class="n">header</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">header</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+=</span> <span class="sa">b</span><span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">required</span> <span class="o">=</span> <span class="p">[</span><span class="sa">b</span><span class="s1">&#39;WIDTH&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;HEIGHT&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;DEPTH&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;MAXVAL&#39;</span><span class="p">]</span>
    <span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">DEPTH</span><span class="p">,</span> <span class="n">MAXVAL</span> <span class="o">=</span> <span class="n">required</span>
    <span class="n">present</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">required</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">header</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">present</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">required</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">Error</span><span class="p">(</span><span class="s1">&#39;PAM file must specify WIDTH, HEIGHT, DEPTH, and MAXVAL&#39;</span><span class="p">)</span>
    <span class="n">width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="n">WIDTH</span><span class="p">])</span>
    <span class="n">height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="n">HEIGHT</span><span class="p">])</span>
    <span class="n">depth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="n">DEPTH</span><span class="p">])</span>
    <span class="n">maxval</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="n">MAXVAL</span><span class="p">])</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">width</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">height</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">depth</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">maxval</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">Error</span><span class="p">(</span>
            <span class="s1">&#39;WIDTH, HEIGHT, DEPTH, MAXVAL must all be positive integers&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;P7&#39;</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">maxval</span>


<span class="k">def</span> <span class="nf">read_pnm_header</span><span class="p">(</span><span class="n">infile</span><span class="p">,</span> <span class="n">supported</span><span class="o">=</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;P5&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;P6&#39;</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read a PNM header, returning (format,width,height,depth,maxval).</span>
<span class="sd">    `width` and `height` are in pixels.  `depth` is the number of</span>
<span class="sd">    channels in the image; for PBM and PGM it is synthesized as 1, for</span>
<span class="sd">    PPM as 3; for PAM images it is read from the header.  `maxval` is</span>
<span class="sd">    synthesized (as 1) for PBM images.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Generally, see http://netpbm.sourceforge.net/doc/ppm.html</span>
    <span class="c1"># and http://netpbm.sourceforge.net/doc/pam.html</span>

    <span class="c1"># Technically &#39;P7&#39; must be followed by a newline, so by using</span>
    <span class="c1"># rstrip() we are being liberal in what we accept.  I think this</span>
    <span class="c1"># is acceptable.</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="n">infile</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">supported</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;file format </span><span class="si">%s</span><span class="s1"> not supported&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;P7&#39;</span><span class="p">:</span>
        <span class="c1"># PAM header parsing is completely different.</span>
        <span class="k">return</span> <span class="n">read_pam_header</span><span class="p">(</span><span class="n">infile</span><span class="p">)</span>
    <span class="c1"># Expected number of tokens in header (3 for P4, 4 for P6)</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">pbm</span> <span class="o">=</span> <span class="p">(</span><span class="sa">b</span><span class="s1">&#39;P1&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;P4&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span> <span class="ow">in</span> <span class="n">pbm</span><span class="p">:</span>
        <span class="n">expected</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">header</span> <span class="o">=</span> <span class="p">[</span><span class="nb">type</span><span class="p">]</span>

    <span class="c1"># We have to read the rest of the header byte by byte because the</span>
    <span class="c1"># final whitespace character (immediately following the MAXVAL in</span>
    <span class="c1"># the case of P6) may not be a newline.  Of course all PNM files in</span>
    <span class="c1"># the wild use a newline at this point, so it&#39;s tempting to use</span>
    <span class="c1"># readline; but it would be wrong.</span>
    <span class="k">def</span> <span class="nf">getc</span><span class="p">():</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">infile</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Error</span><span class="p">(</span><span class="s1">&#39;premature EOF reading PNM header&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">c</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">getc</span><span class="p">()</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># Skip whitespace that precedes a token.</span>
        <span class="k">while</span> <span class="n">c</span><span class="o">.</span><span class="n">isspace</span><span class="p">():</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">getc</span><span class="p">()</span>
        <span class="c1"># Skip comments.</span>
        <span class="k">while</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;#&#39;</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\n\r</span><span class="s1">&#39;</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">getc</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">Error</span><span class="p">(</span><span class="s1">&#39;unexpected character </span><span class="si">%s</span><span class="s1"> found in header&#39;</span> <span class="o">%</span> <span class="n">c</span><span class="p">)</span>
        <span class="c1"># According to the specification it is legal to have comments</span>
        <span class="c1"># that appear in the middle of a token.</span>
        <span class="c1"># This is bonkers; I&#39;ve never seen it; and it&#39;s a bit awkward to</span>
        <span class="c1"># code good lexers in Python (no goto).  So we break on such</span>
        <span class="c1"># cases.</span>
        <span class="n">token</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span>
        <span class="k">while</span> <span class="n">c</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="n">token</span> <span class="o">+=</span> <span class="n">c</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">getc</span><span class="p">()</span>
        <span class="c1"># Slight hack.  All &quot;tokens&quot; are decimal integers, so convert</span>
        <span class="c1"># them here.</span>
        <span class="n">header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">token</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">==</span> <span class="n">expected</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="c1"># Skip comments (again)</span>
    <span class="k">while</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;#&#39;</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39;</span><span class="se">\n\r</span><span class="s1">&#39;</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">getc</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">isspace</span><span class="p">():</span>
        <span class="k">raise</span> <span class="n">Error</span><span class="p">(</span><span class="s1">&#39;expected header to end with whitespace, not </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">c</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">type</span> <span class="ow">in</span> <span class="n">pbm</span><span class="p">:</span>
        <span class="c1"># synthesize a MAXVAL</span>
        <span class="n">header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">depth</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)[</span><span class="nb">type</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;P6&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">header</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">header</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">depth</span><span class="p">,</span> <span class="n">header</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">write_pnm</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">pixels</span><span class="p">,</span> <span class="n">meta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Write a Netpbm PNM/PAM file.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bitdepth</span> <span class="o">=</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;bitdepth&#39;</span><span class="p">]</span>
    <span class="n">maxval</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">bitdepth</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="c1"># Rudely, the number of image planes can be used to determine</span>
    <span class="c1"># whether we are L (PGM), LA (PAM), RGB (PPM), or RGBA (PAM).</span>
    <span class="n">planes</span> <span class="o">=</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;planes&#39;</span><span class="p">]</span>
    <span class="c1"># Can be an assert as long as we assume that pixels and meta came</span>
    <span class="c1"># from a PNG file.</span>
    <span class="k">assert</span> <span class="n">planes</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">planes</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">if</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">planes</span><span class="p">:</span>
            <span class="c1"># PGM</span>
            <span class="c1"># Could generate PBM if maxval is 1, but we don&#39;t (for one</span>
            <span class="c1"># thing, we&#39;d have to convert the data, not just blat it</span>
            <span class="c1"># out).</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;P5&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># PPM</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;P6&#39;</span>
        <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> </span><span class="si">%d</span><span class="s1"> </span><span class="si">%d</span><span class="s1"> </span><span class="si">%d</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">maxval</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">planes</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
        <span class="c1"># PAM</span>
        <span class="c1"># See http://netpbm.sourceforge.net/doc/pam.html</span>
        <span class="k">if</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">planes</span><span class="p">:</span>
            <span class="n">tupltype</span> <span class="o">=</span> <span class="s1">&#39;GRAYSCALE_ALPHA&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tupltype</span> <span class="o">=</span> <span class="s1">&#39;RGB_ALPHA&#39;</span>
        <span class="n">header</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;P7</span><span class="se">\n</span><span class="s1">WIDTH </span><span class="si">%d</span><span class="se">\n</span><span class="s1">HEIGHT </span><span class="si">%d</span><span class="se">\n</span><span class="s1">DEPTH </span><span class="si">%d</span><span class="se">\n</span><span class="s1">MAXVAL </span><span class="si">%d</span><span class="se">\n</span><span class="s1">&#39;</span>
                  <span class="s1">&#39;TUPLTYPE </span><span class="si">%s</span><span class="se">\n</span><span class="s1">ENDHDR</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span>
                  <span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">planes</span><span class="p">,</span> <span class="n">maxval</span><span class="p">,</span> <span class="n">tupltype</span><span class="p">))</span>
    <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">header</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>
    <span class="c1"># Values per row</span>
    <span class="n">vpr</span> <span class="o">=</span> <span class="n">planes</span> <span class="o">*</span> <span class="n">width</span>
    <span class="c1"># struct format</span>
    <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;&gt;</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">vpr</span>
    <span class="k">if</span> <span class="n">maxval</span> <span class="o">&gt;</span> <span class="mh">0xff</span><span class="p">:</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span> <span class="o">+</span> <span class="s1">&#39;H&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span> <span class="o">+</span> <span class="s1">&#39;B&#39;</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">pixels</span><span class="p">:</span>
        <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="o">*</span><span class="n">row</span><span class="p">))</span>
    <span class="n">file</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">color_triple</span><span class="p">(</span><span class="n">color</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a command line colour value to a RGB triple of integers.</span>
<span class="sd">    FIXME: Somewhere we need support for greyscale backgrounds etc.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">color</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">color</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">16</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">color</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">16</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">color</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">16</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">color</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">color</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="mi">16</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">color</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">],</span> <span class="mi">16</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">color</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">7</span><span class="p">],</span> <span class="mi">16</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">color</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="o">==</span> <span class="mi">13</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">color</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">],</span> <span class="mi">16</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">color</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">9</span><span class="p">],</span> <span class="mi">16</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">color</span><span class="p">[</span><span class="mi">9</span><span class="p">:</span><span class="mi">13</span><span class="p">],</span> <span class="mi">16</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_add_common_options</span><span class="p">(</span><span class="n">parser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Call *parser.add_option* for each of the options that are</span>
<span class="sd">    common between this PNG--PNM conversion tool and the gen</span>
<span class="sd">    tool.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span>
        <span class="s2">&quot;-i&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--interlace&quot;</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;create an interlaced PNG file (Adam7)&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span>
        <span class="s2">&quot;-t&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--transparent&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;string&quot;</span><span class="p">,</span>
        <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;#RRGGBB&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;mark the specified colour as transparent&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span>
        <span class="s2">&quot;-b&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--background&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;string&quot;</span><span class="p">,</span>
        <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;#RRGGBB&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;save the specified background colour&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span>
        <span class="s2">&quot;-g&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--gamma&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">,</span>
        <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;save the specified gamma value&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span>
        <span class="s2">&quot;-c&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--compression&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">,</span>
        <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;level&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;zlib compression level (0-9)&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">parser</span>


<span class="k">def</span> <span class="nf">_main</span><span class="p">(</span><span class="n">argv</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run the PNG encoder with options from the command line.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Parse command line arguments</span>
    <span class="kn">from</span> <span class="nn">optparse</span> <span class="k">import</span> <span class="n">OptionParser</span>
    <span class="n">version</span> <span class="o">=</span> <span class="s1">&#39;%prog &#39;</span> <span class="o">+</span> <span class="n">__version__</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">OptionParser</span><span class="p">(</span><span class="n">version</span><span class="o">=</span><span class="n">version</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">set_usage</span><span class="p">(</span><span class="s2">&quot;%prog [options] [imagefile]&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span>
        <span class="s1">&#39;-r&#39;</span><span class="p">,</span>
        <span class="s1">&#39;--read-png&#39;</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Read PNG, write PNM&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span>
        <span class="s2">&quot;-a&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--alpha&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;string&quot;</span><span class="p">,</span>
        <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;pgmfile&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;alpha channel transparency (RGBA)&quot;</span><span class="p">)</span>
    <span class="n">_add_common_options</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span>

    <span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="c1"># Convert options</span>
    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">transparent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">options</span><span class="o">.</span><span class="n">transparent</span> <span class="o">=</span> <span class="n">color_triple</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">transparent</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">background</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">options</span><span class="o">.</span><span class="n">background</span> <span class="o">=</span> <span class="n">color_triple</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">background</span><span class="p">)</span>

    <span class="c1"># Prepare input and output files</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">infilename</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
        <span class="n">infile</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">infilename</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">infile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">infilename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;more than one input file&quot;</span><span class="p">)</span>
    <span class="n">outfile</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;win32&quot;</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">msvcrt</span><span class="o">,</span> <span class="nn">os</span>
        <span class="n">msvcrt</span><span class="o">.</span><span class="n">setmode</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">O_BINARY</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">read_png</span><span class="p">:</span>
        <span class="c1"># Encode PNG to PPM</span>
        <span class="n">png</span> <span class="o">=</span> <span class="n">Reader</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="n">infile</span><span class="p">)</span>
        <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">pixels</span><span class="p">,</span> <span class="n">meta</span> <span class="o">=</span> <span class="n">png</span><span class="o">.</span><span class="n">asDirect</span><span class="p">()</span>
        <span class="n">write_pnm</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">pixels</span><span class="p">,</span> <span class="n">meta</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Encode PNM to PNG</span>
        <span class="nb">format</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">maxval</span> <span class="o">=</span> \
          <span class="n">read_pnm_header</span><span class="p">(</span><span class="n">infile</span><span class="p">,</span> <span class="p">(</span><span class="sa">b</span><span class="s1">&#39;P5&#39;</span><span class="p">,</span><span class="sa">b</span><span class="s1">&#39;P6&#39;</span><span class="p">,</span><span class="sa">b</span><span class="s1">&#39;P7&#39;</span><span class="p">))</span>
        <span class="c1"># When it comes to the variety of input formats, we do something</span>
        <span class="c1"># rather rude.  Observe that L, LA, RGB, RGBA are the 4 colour</span>
        <span class="c1"># types supported by PNG and that they correspond to 1, 2, 3, 4</span>
        <span class="c1"># channels respectively.  So we use the number of channels in</span>
        <span class="c1"># the source image to determine which one we have.  We do not</span>
        <span class="c1"># care about TUPLTYPE.</span>
        <span class="n">greyscale</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">&lt;=</span> <span class="mi">2</span>
        <span class="n">pamalpha</span> <span class="o">=</span> <span class="n">depth</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">supported</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">17</span><span class="p">)]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mi</span> <span class="o">=</span> <span class="n">supported</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">maxval</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s1">&#39;your maxval (</span><span class="si">%s</span><span class="s1">) not in supported list </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                <span class="p">(</span><span class="n">maxval</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">supported</span><span class="p">)))</span>
        <span class="n">bitdepth</span> <span class="o">=</span> <span class="n">mi</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">writer</span> <span class="o">=</span> <span class="n">Writer</span><span class="p">(</span>
            <span class="n">width</span><span class="p">,</span>
            <span class="n">height</span><span class="p">,</span>
            <span class="n">greyscale</span><span class="o">=</span><span class="n">greyscale</span><span class="p">,</span>
            <span class="n">bitdepth</span><span class="o">=</span><span class="n">bitdepth</span><span class="p">,</span>
            <span class="n">interlace</span><span class="o">=</span><span class="n">options</span><span class="o">.</span><span class="n">interlace</span><span class="p">,</span>
            <span class="n">transparent</span><span class="o">=</span><span class="n">options</span><span class="o">.</span><span class="n">transparent</span><span class="p">,</span>
            <span class="n">background</span><span class="o">=</span><span class="n">options</span><span class="o">.</span><span class="n">background</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">pamalpha</span> <span class="ow">or</span> <span class="n">options</span><span class="o">.</span><span class="n">alpha</span><span class="p">),</span>
            <span class="n">gamma</span><span class="o">=</span><span class="n">options</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span>
            <span class="n">compression</span><span class="o">=</span><span class="n">options</span><span class="o">.</span><span class="n">compression</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">alpha</span><span class="p">:</span>
            <span class="n">pgmfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
            <span class="nb">format</span><span class="p">,</span> <span class="n">awidth</span><span class="p">,</span> <span class="n">aheight</span><span class="p">,</span> <span class="n">adepth</span><span class="p">,</span> <span class="n">amaxval</span> <span class="o">=</span> \
              <span class="n">read_pnm_header</span><span class="p">(</span><span class="n">pgmfile</span><span class="p">,</span> <span class="s1">&#39;P5&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">amaxval</span> <span class="o">!=</span> <span class="s1">&#39;255&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s1">&#39;maxval </span><span class="si">%s</span><span class="s1"> not supported for alpha channel&#39;</span> <span class="o">%</span> <span class="n">amaxval</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">awidth</span><span class="p">,</span> <span class="n">aheight</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;alpha channel image size mismatch&quot;</span>
                                 <span class="s2">&quot; (</span><span class="si">%s</span><span class="s2"> has </span><span class="si">%s</span><span class="s2">x</span><span class="si">%s</span><span class="s2"> but </span><span class="si">%s</span><span class="s2"> has </span><span class="si">%s</span><span class="s2">x</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="n">infilename</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">options</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span>
                                  <span class="n">awidth</span><span class="p">,</span> <span class="n">aheight</span><span class="p">))</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">convert_ppm_and_pgm</span><span class="p">(</span><span class="n">infile</span><span class="p">,</span> <span class="n">pgmfile</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">convert_pnm</span><span class="p">(</span><span class="n">infile</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">_main</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">Error</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Huangying Zhan

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>